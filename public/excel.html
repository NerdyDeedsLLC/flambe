<html>

<head>
    <title>read-excel-file</title>
    <meta charset="utf-8">
    <script src="./lib/js/csv-to-json.js"></script>
    <link rel="stylesheet" href="lib/css/excel.css">
    <style>

    </style>
</head>

<body>
    <main>
        <form id='iteration-info' action="">
            <section class="form-fields">
                <div>
                    <input id="iteration-name" name="iteration-name" type="text" required class="input-field"
                        autocomplete="false" placeholder="" />
                    <label for="iteration-name" class="iteration-name-label">Iteration Name <em>(this is a label that
                            will appled to reports in this iteration)</em></label>
                </div>
                <div>
                    <input id="report-start-date" name="report-start-date" type="date" required class="datepicker"
                        autocomplete="false" placeholder="" />
                    <label for="report-start-date" class="report-start-date-label">Burndown Chart Start Date <em>(The
                            day the Iteration began)</em></label>
                </div>
            </section>
            <section class="file-drop-target">
                <label id="file-dropzone" class="file-dropzone" for="input">
                    <input type="file" id="input" name="input" multiple>
                </label>
            </section>
        </form>
        <div class="sort-order">
            <ul class="has-draggable-children"></ul>
            <button class="insert-missing-day" onclick="insertDay(this)" disabled="true">Add Another Slot</button>
            <button class="done-sorting" onclick="runReport(this)" disabled="true">Okay, I'm satisfied. Run it!</button>
        </div>
        <div class="pbars">
        </div>
        <div class="output-table">
            <table>
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>
    </main>
    <script>
        // DECLARATIONS ==================================================================================================================
        // Shortcut aliases and Helper functions -----------------------------------------------------------------------------------------
        const d = document                                       // ⥱ Alias - document
            , qs = (s) => d.querySelector(s)                        // ⥱ Alias - querySelector
            , qsa = (s) => [...d.querySelectorAll(s)]                // ⥱ Alias - querySelectorAll
            , _ = (...args) => console.log.call(this, ...args)     // ⥱ Alias - _
            , pBar = (id, title, barColor, processor = 1, seq = 0, bc = 0) =>     // ⍟ HLPfn - Generates a progress bar
                new Promise(conclude => {
                    id = 'pbar-' + id;
                    let oldBar = qs('#' + id);
                    if (oldBar) oldBar.remove();
                    let pb = qs('.pbars');
                    pb.insertAdjacentHTML('beforeEnd', `<div id="${id}" class="progress-bar" title="${title}" style="--bar-color:${barColor}; --process:${processor}s; --seq:${seq}; --bc:${bc}"></div>`)
                    return conclude(qs('#' + id));
                })
            , rote = window.localStorage
            , memories = a => rote.length
            , recall = a => rote.getItem.call(this, ...args)
            , retain = a => rote.setItem.call(this, ...args)
            , forget = a => rote.removeItem.call(this, ...args)
            , recollect = a => rote.getItem.call(this, ...args)
            , fugue = a => rote.clear.call(this, ...args)
            , toHours = (val = null) => {
                if (val == null || isNaN((val / 1))) return '';
                val = (val / 1);
                if (val <= 0) return 0;
                return (val / 3600).toPrecision(3);
            }



        // Global Variables --------------------------------------------------------------------------------------------------------------
        let   fileBuffer = []     // Stores copies of the file input's data collection (req'd in case the user maskes multiple sets of selections)
            , namedFiles = []     // Array containing just the names of the files contained within fileBuffer (used for sequencing the read order)
            , COMBD_DATA = []
            , ISSUE_KEYS = []
            , input = document.getElementById('input')
            , sortableList = qs('.has-draggable-children')
            , doneButton = qs('.done-sorting')
            , concernColors = ['Transparent', 'DimGray', 'GreenYellow', 'Gold', 'Orange', 'Red']

            , concernFlags = {  // CONCERN CODEX
                                "HID":    {"weight": 0, "concern": "Hidden By ScrumMaster" },
                                "ATT":    {"weight": 1, "concern": "Related to Attendance" },
                                "HOL":    {"weight": 1, "concern": "Related to Holiday" },
                                "EST":    {"weight": 2, "concern": "Bad Estimate" },
                                "AUC":    {"weight": 2, "concern": "Assigned User Changed" },
                                "UER":    {"weight": 2, "concern": "User Error" },
                                "SCR":    {"weight": 2, "concern": "Scope Creep" },
                                "ASS":    {"weight": 2, "concern": "Improperly Assigned" },
                                "USS":    {"weight": 3, "concern": "Unestimated at Sprint Start" },
                                "STK":    {"weight": 3, "concern": "Unable to Begin" },
                                "STR":    {"weight": 3, "concern": "Bad/Mistaken Story Inclusion" },
                                "HRS":    {"weight": 3, "concern": "Hours Not Being Burned" },
                                "NPR":    {"weight": 3, "concern": "No Progress Reported" },
                                "NEW":    {"weight": 4, "concern": "New Story Added to Iteration" },
                                "DEL":    {"weight": 4, "concern": "Story Deleted" },
                                "XXX":    {"weight": 5, "concern": "Blocking Issue" },
                                // BUNDLES
                                "UNCHGD": {"weight": 2, "collection": "XXX,NPR,STK,HOL,ATT,HRS",     "concern": "No changes made to story for current iteration" },
                                "HRSINC": {"weight": 3, "collection": "EST,UER,SCR,STR,STK,NEW,ASS", "concern": "Hour increase from day prior!" },
                                "UNCHG3": {"weight": 4, "collection": "XXX,NPR,STK,HOL,ATT,HRS",     "concern": "No changes made to story for 3 days!" }
                            }
    
        // APPLICATION SOURCE ============================================================================================================
        parseFilesAndGenerateDragDrop = response =>                                      // ⓵ onChange of file input box, iterate namedFiles and generate Drag/Drop UL
            new Promise(conclude => {
                const bufferFile = (fileObj, fileIndex, fileName) =>
                    new Promise(fulfill => {
                        fileName = fileObj.name;
                        if (namedFiles.indexOf(fileName) !== -1) return fulfill(this);
                        namedFiles.push(fileName);
                        const appendToBuffer = (JSONObj, fileName = null) => {
                            let extantIndex = fileBuffer.find(b => b.fileName === fileName);
                            if (extantIndex) fileBuffer[extantIndex] = JSONObj;
                            else fileBuffer.push({ fileName: fileName, fileData: JSONObj })
                        };
                        var reader = new FileReader();                               // Instantiate a new file reader...
                        //   ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  
                        reader.onloadend = (progressEvent) => {                       //    ... Add a listener to observe once it's finished loading.
                            var opJSON = CSV.parse(reader.result);                        //    Parse the .CSV file input...
                            appendToBuffer(opJSON, fileName);                                     //    ... and add it to the global variable containing file data,

                            return fulfill(this);
                        };                                                              // ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  
                        reader.readAsText(fileObj);                                     // ... And read the file specified.
                    });
                var previousFileCount = namedFiles.length;
                var bufferedFiles = Promise.all([...input.files].map((file, ind) => bufferFile(file, ind, file.name)))
                .then(() => {
                        namedFiles = [...new Set(namedFiles)];

                        let opStr = '';
                        for (var i = 0; i < 11; i++) {
                            let dataSlot = !i ? "S" : i;
                            if (i < namedFiles.length) {
                                let fileName = namedFiles[i];
                                opStr += `<li data-slot="${dataSlot}" class="drag-drop" draggable="true">${fileName}</li>`
                            } else {
                                opStr += `<li data-slot="${dataSlot}"><label for="input">No file specified (click to add!)</label></li>`;
                            }
                        }
                        while (sortableList.childElementCount > 0) sortableList.childNodes[0].remove()
                        sortableList.insertAdjacentHTML('beforeEnd', opStr);
                        return conclude(response);
                    });
            });
        const primeDragDropListBehaviors = (listClass = 'drag-drop') => {           // ⓶ iterate UL and set up drag/drop on its children
            const bindDragDropListeners = (obj) => {
                try {

                    const drag = (e, trg = e.target, parList = trg.parentNode) => {
                        trg.className += " drag-sort-active";
                        let swapobj = document.elementFromPoint(event.clientX, event.clientY) || trg;
                        if (parList === swapobj.parentNode) {
                            // Thereby constraining the drop to the same list
                            swapobj = (swapobj !== trg.nextSibling) ? swapobj : swapobj.nextSibling;
                            parList.insertBefore(trg, swapobj);
                        }
                    };
                    const drop = (e, trg = e.target) => { e.preventDefault(); trg.className = trg.className.replace(/(\s+)?drag-sort-active(\s+)?/g, ""); }

                    obj.addEventListener("drag", drag);
                    obj.addEventListener("drop", drop);
                    obj.addEventListener("dragend", drop);
                    return true;
                } catch (err) {
                    return false;
                }
            }
            let ddObjects = sortableList.getElementsByClassName(listClass);
            Array.prototype.map.call(ddObjects,
                list => {
                    Array.prototype.map.call(list.children, item => {
                        bindDragDropListeners(item);
                    });
                }
            );
            [...ddObjects].forEach(o => bindDragDropListeners(o));
            doneButton.disabled = false;
            // retain(
        }
        const runReport = (obj) => {                                                // ⓷ user clicks Run It!; orchastrate remaining steps
            if (obj.disabled == true) return false;
            COMBD_DATA = [];
            ISSUE_KEYS = [];
            DEBUG_DATA = [];
            getDistinctKeysFromFiles();
        }
        const getDistinctKeysFromFiles = () =>                                      // ⓸ iterate files in buffer create promise chain to read each in sequence
            new Promise(resolve => {
                pBar(3, 'PROCESSING', 'aquamarine', 1, 0, 0);
                for (files in fileBuffer) {
                    let file = fileBuffer[files].fileData;
                    let keySet = JSON.stringify(file, ['Issue key'])                //    ... convert the resultant JSON to a string containing ONLY the 'Issue key' column...
                        .match(/DIGTDEV-\d{4,6}/g)                                  //    ... and then search the pattern DIGTDEV-####(##) out (any 4-6-digit number)
                    ISSUE_KEYS = [...new Set([...ISSUE_KEYS, ...keySet])]           //    ... combine keySet and ISSUE_KEYS, remove duplicates, and convert back to an array.
                }

                concatinateDataFromSequencedFiles()
            });

        const concatinateDataFromSequencedFiles = () => {                           // ⓹ iterate finalized buffer, and concatinated generate output data
            temp_store = [];
            ISSUE_KEYS.forEach(r => {
                temp_store.push(r['Issue key']);
                COMBD_DATA[r] = new Array(fileBuffer.length).fill('');
                DEBUG_DATA[r] = new Array(fileBuffer.length).fill('');
            });

            for (files in fileBuffer) {
                let file = fileBuffer[files].fileData;
                file.forEach(f => {
                    if (f && f['Issue key'] && f['Issue key'] != null && f['Issue key'] !== '') {
                        COMBD_DATA[f['Issue key']][files] = f;
                        DEBUG_DATA[f['Issue key']][files] = JSON.stringify(f);
                    }
                });
            }
            _(DEBUG_DATA)
            output = []

            let flagCodex = 
            Object.entries(COMBD_DATA).forEach((dataRecord, ind) => {
                let issue = dataRecord[0],
                    flags = [];
                    data  = dataRecord[1],
                    datCt = Object.entries(data).length; // How many "collumns" we're looking at
                    op    = '',
                    oldRE = '',
                    reCtr = 1,
                    ctCtr = 1,
                    oldPI = '',
                    oldII = '',
                    oldST = '',
                    newRE = '',
                    newPI = '',
                    newII = '',
                    newST = '';

                data.forEach((datRec, ix) => { 
                    newRE = datRec['Remaining Estimate']  || '';
                    newPI = datRec['Parent id']           || '';
                    newII = datRec['Issue id']            || '';
                    newST = datRec['Status']              || '';
                    if(newRE !== oldRE) {
                        if(newRE > oldRE){          // Estimated Hours INcreased (Bad Estimate? Bad Story Inclusion? New Story Added? Scope Creep?)

                        }                           // If they've DEcreased we're on the happy path.
                        reCtr = 1;                  // It's changed for the good or the bad. Reset our "same" counter;
                        ctCtr = 0;                  // It's changed at SOME POINT. Remove this counter from consideration;
                    }else{                          // Estimated Hours Havent Changed (ergo, no burndown)
                        if(reCtr > 3){              // Unchanged for 3+ days... 
                            if(reCtr === ctCtr){    // ... and hasn't for the duration being examined. FLAG (No burndown? Blocked? No Progress? Possible Bad Story)

                            }
                        }
                        reCtr++;                    // Increment our "same" counter
                        if(!!ctCtr) ctCtr++;        // If our Issue-wide "same" counter is still in play (i.e. it's NEVER changed), increment
                    }
                    // newPI = (newPI === datRec['Parent id']) ? newPI : datRec['Parent id'] || '';
                    // newII = (newII === datRec['Issue id'])  ? newII : datRec['Issue id']  || '';
                    // newST = (newST === datRec['Status'])    ? newST : datRec['Status']    || '';
                    op = op + '||--||' + toHours(newRE) + 'h' ;
                });

                op = newST + "||--||" + issue + "||--||" + newPI + "||--||" + newII + "||--||" + op;
                output.push(op.split('||--||'));
            })

            pBar(4, 'GENERATING OUTPUT... DONE!', 'LimeGreen', 0.1, 0.1, 0.1);

            let th = "<tr><th>Current Status</th><th>Issue</th><th>Parent ID</th><th>Issue ID</th>";
            let dateField = qs("#report-start-date");
            let dateArr = [];
            if (dateField.checkValidity()) {
                th += "<th>Seed<br/>" + dateField.value + "</th><th>Day "
                let startDate = new Date(dateField.value).getTime();
                let dayCt = 1;
                while (dateArr.length < 10 && dayCt < 50) {
                    cDate = new Date(startDate + (dayCt * 86400000));
                    if (cDate.getDay() > 0 && cDate.getDay() < 6) dateArr.push((dateArr.length + 1) + '<br />' + cDate.toLocaleDateString())
                    dayCt++;
                }
            } else {
                dateArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            }
            th += dateArr.join('</th><th>Day ') + '</tr>';
            let mu = '';
            output.forEach(o => {
                mu += '<tr><td>' + o.join('</td><td>') + '</td></tr>';
            });
            let previewPanel = qs('.output-table');
            while (previewPanel.childElementCount > 0) previewPanel.childNodes[0].remove()
            previewPanel.insertAdjacentHTML('beforeEnd', '<h1>' + qs("#iteration-name").value + '</h1><table>' + th + mu.replace(/\.00h|\.0h/g, 'h') + '</table>');
            return true;
        }
        (init = () => {                                                             // ⓿ Initiate application, chaining steps 1-3 above to file input's onChange
            input.addEventListener('change', () => {

                return pBar(1, "READING...✓", "teal", 0.1, 0, 0)
                    .then(() => pBar(2, 'PARSING...✓', 'DarkTurquoise', 0.1, 0.1, 0.1))
                    // .then(parseNamesOfSelectedFiles)
                    .then(parseFilesAndGenerateDragDrop)
                    .then(primeDragDropListBehaviors);
            });
        })();
    </script>
</body>

</html>