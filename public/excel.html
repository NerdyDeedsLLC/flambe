<html>

<head>
    <title>read-excel-file</title>
    <meta charset="utf-8">
     <script src="./lib/js/csv-to-json.js"></script>
    
    <link rel="stylesheet" href="lib/css/excel.css">
    <style>
       

    </style>
</head>

<body>
    
    <main>
    <form id='iteration-info' action="">
        <section class="form-fields">
            <div>
                <input id="iteration-name" name="iteration-name" type="text" required class="input-field" autocomplete="false" placeholder="" />
                <label for="iteration-name" class="iteration-name-label">Iteration Name <em>(this is a label that will appled to reports in this iteration)</em></label>
            </div>
            <div>
                <input id="report-start-date" name="report-start-date" type="date" required class="datepicker" autocomplete="false" placeholder="" />
                <label for="report-start-date" class="report-start-date-label">Burndown Chart Start Date <em>(The day the Iteration began)</em></label>
            </div>
        </section>
        <section class="file-drop-target">

            <label id="file-dropzone" class="file-dropzone" for="input">
                <input type="file" id="input" name="input" multiple>
            </label>
        </section>
    </form>
    <div class="sort-order">
        <ul class="has-draggable-children"></ul>
        <button class="done-sorting" onclick="runReport()">Okay, I'm satisfied. Run it!</button>
    </div>
    <div class="pbars">
       <div id="pbar4"  title="GENERATING OUTPUT... DONE!" style="--bar-color:LimeGreen; --process:0.2s; --seq:7.7s; --bc:7.4;"></div>
    </div>
    <div class="output-table">
        <table>
            <thead></thead>
            <tbody></tbody>
        </table>
    </div>
    </main>
    <script>
    
    // DECLARATIONS ==================================================================================================================
    // Shortcut aliases and Helper functions -----------------------------------------------------------------------------------------
    const d            = document                                       // ⥱ Alias - document
         ,qs           = (s)=>d.querySelector(s)                        // ⥱ Alias - querySelector
         ,qsa          = (s)=>[...d.querySelectorAll(s)]                // ⥱ Alias - querySelectorAll
         ,pBar = (id, title, barColor, processor=1, seq=0, bc=0) =>     // ⍟ HLPfn - Generates a progress bar
                 new Promise(conclude => {
                    id ='pbar-' + id;
                    let oldBar = qs('#' + id);
                    if(oldBar) oldBar.remove();
                    let pb = qs('.pbars');
                    pb.insertAdjacentHTML('beforeEnd', `<div id="${id}" class="progress-bar" title="${title}" style="--bar-color:${barColor}; --process:${processor}s; --seq:${seq}; --bc:${bc}"></div>`)
                    return conclude(qs('#' + id));
                 });

    // Global Variables --------------------------------------------------------------------------------------------------------------
    let  fileBuffer   = []     // Stores copies of the file input's data collection (req'd in case the user maskes multiple sets of selections)
        ,namedFiles   = []     // Array containing just the names of the files contained within fileBuffer (used for sequencing the read order)
        ,COMBD_DATA   = []     
        ,ISSUE_KEYS   = []
        ,input        = document.getElementById('input')
        ,sortableList = qs('.has-draggable-children');

    // APPLICATION SOURCE ============================================================================================================
    const parseNamesOfSelectedFiles = response =>                      // ⓵ onChange of file input box, construct namedFiles collection
        new Promise(conclude => {
            console.log('- Parsing & Sorting File Names...')
            for(let i=0; i<input.files.length; i++) {
                
            }
            console.log('   -', namedFiles.join('\n   - '), ' - FileBuffer:', fileBuffer);
            
            return conclude(true);
        });
        
    const parseFilesAndGenerateDragDrop = response =>                // ⓶ iterate namedFiles and generate Drag/Drop UL
        new Promise(conclude => {

            const bufferFile = (fileObj, fileIndex, fileName) => 
            new Promise(fulfill => {
                    fileName = fileObj.name;
                    if(namedFiles.indexOf(fileName) !== -1) return fulfill(this);
                    namedFiles.push(fileName);
                    const appendToBuffer = (JSONObj, fileName=null) => {
                        let extantIndex = fileBuffer.find(b=>b.fileName===fileName);
                        if(extantIndex) fileBuffer[extantIndex] = JSONObj;
                        else fileBuffer.push({fileName:fileName, fileData:JSONObj})
                    };
                    console.group('Ingesting file ' + fileName + '...')
                    var reader    = new FileReader();                               // Instantiate a new file reader...
                                                                                    //   ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  
                    reader.onload = (progressEvent) => {                       //    ... Add a listener to observe once it's finished loading.
                        
                    var opJSON = CSV.parse(reader.result);                        //    Parse the .CSV file input...
                        appendToBuffer(opJSON, fileName);                                     //    ... and add it to the global variable containing file data,
                        console.log(fileName, opJSON);
                        console.groupEnd();
                        return fulfill(this);
                    };                                                              // ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  
                    reader.readAsText(fileObj);                                     // ... And read the file specified.
                });
            var previousFileCount=namedFiles.length;
            var bufferedFiles = Promise.all([...input.files].map((file,ind) => bufferFile(file, ind, file.name))).then(
                () => {
                    namedFiles = [...new Set(namedFiles)];
                    console.log('bufferedFiles', fileBuffer);
                    console.log('Constructing drag/drop ui...');
                    let opStr = '';
                    for (var i = 0; i < 10; i++) {
                        if(i < namedFiles.length){
                            let fileName = namedFiles[i];
                            console.log('   - Creating draggable DOM node for ' + fileName);
                            opStr += `<li data-slot="${i+1}" class="drag-drop" draggable="true">${fileName}</li>`
                        }else{
                            opStr += `<li data-slot="${i+1}"><label for="input">No file specified (click to add!)</label></li>`;
                        }
                    }
                    console.log('   - Clearing current DOM structure of list...');
                    while(sortableList.childElementCount > 0) sortableList.childNodes[0].remove()
                    console.log('   - Inserting new draggable DOM structure...');
                    sortableList.insertAdjacentHTML('beforeEnd', opStr);
                    console.log('   - Binding event handlers...');
                    return conclude(response);
                });
        });

    const primeDragDropListBehaviors = (listClass='drag-drop') => {    // ⓷ iterate UL and set up drag/drop on its children
        
        const bindDragDropListeners = (obj) => {
            try {
                console.log('     Attempting to bind listeners to', obj);

                const drag = (e, trg = e.target, parList = trg.parentNode) => {
                    trg.className += " drag-sort-active";
                    let swapobj = document.elementFromPoint(event.clientX, event.clientY) || trg;

                    if (parList === swapobj.parentNode) {
                        // Thereby constraining the drop to the same list
                        swapobj = (swapobj !== trg.nextSibling) ? swapobj : swapobj.nextSibling;
                        parList.insertBefore(trg, swapobj);
                    }
                };
                const drop = (e, trg = e.target) => {e.preventDefault(); trg.className = trg.className.replace(/(\s+)?drag-sort-active(\s+)?/g, ""); }

                console.log('Binding drag listeners...');
                obj.addEventListener("drag", drag); 
                console.log('Binding drop listeners...');
                obj.addEventListener("drop", drop);
                console.log('Binding dragend listeners...');
                obj.addEventListener("dragend", drop);
                return true;
            } catch (err) {
                console.error(err);
                return false;
            }
        }
        console.group('Locating DOM elements to convert to drag-droppable...');
        let ddObjects = sortableList.getElementsByClassName(listClass);
        Array.prototype.map.call(ddObjects,
                                 list => {
                                    console.log('     ', ddObjects.length, ' elements located:', ddObjects);
                                    Array.prototype.map.call(list.children, item => {
                                        bindDragDropListeners(item);
                                    });
                                 }
       );

       [...ddObjects].forEach(o=>bindDragDropListeners(o));
       console.groupEnd();
    }

    const runReport = () => {                                           // ⓸ user clicks Run It!; orchastrate remaining steps
        const ingestSingleFile = (fileData) => {
            // return new Promise(resolve=> 
        }



        // var promise1 = () => new Promise(function(conclude, abort) {
        //     for(let i=0; i<input.files.length; i++) 
        //         namedFiles.push(input.files[i].name);
        //     if(OPsettings.autoSorting && input.files) 
        //         namedFiles = namedFiles.sort();
        //     parseFilesAndGenerateDragDrop()
        //     conclude(this);
        // }).then(() => new Promise(function(conclude, abort) {
        //     opStr = '';
        //     for (var i = 0; i < input.files.length; i++) 
        //         readEachFileInSequence(input.files[i], input.files[i].name, new Date(input.files[i].lastModified).toLocaleString());
            
        //     conclude(this);
        // })).then(()=>concatinateDataFromSequencedFiles());
    }

    const reorderFilesInBufferToMatchList = () => {                     // ⓸ grab contents of UL and align namedFiles and buffer
    }
//onloadend
    const readEachFileInSequence = (fileObj, name, date, cb) => {       // ⓹ iterate files in buffer create promise chain to read each in sequence
        const appendToBuffer = (obj, index=null) => (index==null) ? fileBuffer.push(obj) : fileBuffer[index]=obj;
        console.groupCollapsed('Ingesting file ' + name + '...')
        var reader    = new FileReader();                               // Instantiate a new file reader...
                                                                        //   ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  ⌢  
        reader.onload = function(progressEvent) {                       //    ... Add a listener to observe once it's finished loading.
            var opJSON = CSV.parse(this.result);                        //    Parse the .CSV file input...
            appendToBuffer(opJSON);                                     //    ... and add it to the global variable containing file data,
            let keySet = JSON.stringify(opJSON,['Issue key'])           //    ... convert the resultant JSON to a string containing ONLY the 'Issue key' column...
                             .match(/DIGTDEV-\d{4,6}/g)                 //    ... and then search the pattern DIGTDEV-####(##) out (any 4-6-digit number)
            ISSUE_KEYS = [...new Set([...ISSUE_KEYS, ...keySet])]       //    ... combine keySet and ISSUE_KEYS, remove duplicates, and convert back to an array.
            console.log(name, '-----------------------------------\nopJSON ============================\n', opJSON, '-----------------------------------\nISSUE_KEYS (de-duped) ============================\n', ISSUE_KEYS);
        };                                                              // ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  ⌣  
        reader.readAsText(fileObj);                                     // ... And read the file specified.
    }

    const concatinateDataFromSequencedFiles = () => {                   // ⓺ iterate finalized buffer, and concatinated generate output data
        pBar(3, 'PROCESSING', 'aquamarine', 1, 0, 0);

        COMBD_DATA = [];
        ISSUE_KEYS = []; 
        DEBUG_DATA = [];
        console.group('Parsing CSV contents into a single structure...');
        fileBuffer.flat().forEach(r => (ISSUE_KEYS.push(r['Issue key']) 
                                    && (COMBD_DATA[r['Issue key']] = new Array(fileBuffer.length).fill(''))
                                    && (DEBUG_DATA[r['Issue key']] = new Array(fileBuffer.length).fill('')))
        );
        console.log(ISSUE_KEYS.length, 'total records found!',
                    '\n     Reducing...');
        ISSUE_KEYS = [...new Set(ISSUE_KEYS)];
        console.log('Unique issues from specified files: ', ISSUE_KEYS.join(', '), 
                    '\n     Constructing combined dataset...');

       for(files in fileBuffer){
            let file = fileBuffer[files];
            console.log('   - Ingesting file #' + files + ': ', file);
            file.forEach(f=>{

                if(f && f['Issue key'] && f['Issue key'] != null && f['Issue key'] !== ''){ 
                    COMBD_DATA[f['Issue key']][files] = f;
                    DEBUG_DATA[f['Issue key']][files] = JSON.stringify(f);
                }
            });
        }
        console.info('Dataset unified. Current state:');
        console.log('RAW DATA ', COMBD_DATA);
        console.log('RAW DATA ', JSON.stringify(Object.entries(COMBD_DATA)));
        console.table(DEBUG_DATA);

        console.groupEnd();
        return true;
    }

    (init = () => {                                                     // ⓿ Initiate application, chaining steps 1-3 above to file input's onChange
        input.addEventListener('change', () => {
            console.group('Files selected! Beginning processing tasks...');

            return   pBar(1,"READING...✓", "teal", 0.1, 0, 0)
                    .then(()=>pBar(2,'PARSING...✓','DarkTurquoise',0.1,0.1,0.1))
                    .then(parseNamesOfSelectedFiles)
                    .then(parseFilesAndGenerateDragDrop)
                    .then(primeDragDropListBehaviors);
            console.groupEnd();
        });
    })();
    </script>
</body>

</html>