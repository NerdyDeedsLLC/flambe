{"version":3,"file":"c_TableStorage.js","sources":["_js/db/c_DBTable.js","_js/db/c_TableStorage.js"],"sourcesContent":["class __DBTable extends Array {\n    constructor(props) {\n        super(props);\n        console.log('__DBTable :', __DBTable, \"\\n   - Props : \", props, this);\n\n        Object.assign(this, props);\n\n        this.__name = props.__name;\n        this.parent = props.__parent;\n        this.root = props.__root;\n        this.isIterable = object => (object != null && typeof object[Symbol.iterator] === 'function');\n        \n        //console.log('this.root.createInstance({name:this.name}) :', this.root.createInstance({name:this.name}));\n        this.root.bindTableInstance(this.__name, this);\n        \n        // Object.assign(this, );\n\n        return\n        // WRITING a record to the table\n        this.write = this.gi = (key, value, force=1) => {\n            if(!!force){                                                                     // IF we're following standard KVP procedure (e.g. inserts and updates ALWAYS behave like overwrites) [FORCE MODE]...\n                return  this.setItem(key, value)                                             // ... set the KVP...\n                        .then(()=>force);                                                    // ... and return 1, signifying the number of records written.\n            }                                                                                // OTHERWISE (we're being cautious and refusing to overwrite extant data, in which case) [CAUTIOUS MODE]...\n            return  this.go(item, null, true)                                                // ... attempt to retrieve the count of the number of records with <key> (0 or 1)\n                    .then(recordExists => (!!recordExists)                                   //   IF a record with <key> exists already... \n                                            ? false                                          //   ...return false, signifying we refused the op and nothing has been changed.\n                                            : this.gi(key, value, true));                    //   OTHERWISE recall this same method in force mode, but send back a true instead of a 1 (which can be coerced to 1 anyway)\n                    \n                \n        }\n\n        // Retrieve a SINGLE record (or the count of same) by <key>, and optionally matching <condition>\n        this.read = this.go = (key, condition, count=false) => {\n            if(condition == null || condition === '') {                                      // IF no condition has been specified [SIMPLE RETRIEVAL]...\n                if (!count) return this.getItem(key);                                        //   IF method is not being called in Count Mode, just retrieve the item with <key>\n                return this.getItem(key)                                                     //   OTHERWISE it IS a count. Attempt to retrieve the item (and since this method ONLY gets one item)...\n                       .then(item=>+(item != null))                                          //   ... then cooerce its boolean test for null (\"is there an item with <key>?\") into its numeric equivalent (0 or 1)\n            }                                                                                // OTHERWISE...\n            return this.getItem(key)                                                         //   Attempt to retrieve the item...\n                   .then(item=> {                                   \n                            if(item == null) return (!count) ? null : 0;                     //   If ITEM *IS NOT* found (it proves to be null/no key exists) return either 0 (if a count op) or null (if not)\n                            return (!count)                                                  //   If IT *IS FOUND*, then...\n                                    ? condition(item)                                        //     ...apply the condition callback and return the results, whatever those should prove to be.\n                                    : condition(item).then(item=>+(item != null));           //   Otherwise apply the condition callback and return the cooerced boolean test for null.\n                        });      \n        }\n\n        // Retrieve ALL records (or the count of same), optionally matching <condition>\n        this.readAll = this.gogo = (condition, includeKeys=false, count=false) => {\n            let tableData = (!includeKeys) ? [] : {};                                        // Create a variable to hold the result set\n            return this.iterate((value,key)=>{                                               // Loop through all the records in this table...\n                if(includeKeys) tableData[key] = value;                                      // ... and IF the user has requested the results in object form, construct the {K:V} JSON...\n                else tableData.push(value);                                                  // ... OTHERWISE just stuff each value into an array...\n                return tableData;                                                            // ... and hand it off to the next processing phase.\n            })\n            .then(() => {                                                                    // RUN THE CONDITIONALS\n                if(condition == null || condition === '') return tableData;                  // IF no condition was set (SELECT * FROM) THEN just pass the whole set along.\n                if(!includeKeys) return tableData.filter(condition);                         // IF, likewise, we're returning an ARRAY, we just filter it through <condition> and pass IT along.\n                return  Object.fromEntries(                                                  // OTHERWISE (we have an OBJECT that needs filtration)...\n                            Object.entries(tableData)                                        // ... convert the data set to an iterable set of KVPs...\n                            .filter(entry=>(condition(entry[1])))                            // ... and use just the value (V) part if the KVPs to ascertain their validity against <condition>, then pass IT along\n                        );\n            })\n            .then(filteredData => (count)                                                    // Finally, IF we're in COUNT MODE...\n                                ? Object.entries(filteredData).length                        // ... return the number of records in the filtered, final set instead of the array/object itself\n                                : filteredData);                                             // OTHERWISE the data set, having been filtered agaist <condition> already can just be passed through.\n        }\n\n        // VIEWING the current \"schema\" (read: the \"shape\" and data types of the data being stored inside at this minute)\n        this.schema = () => {                                                                // NOTE: this method returns the keys (K) for each KVP record stored in this table/bucket to one layer deep, NO VALUES are returned\n            var tableSchema = {};                                                            // Create a variable to hold the result metadata set\n            return db.tables.Teams.iterate((value,key)=>{                                    // Loop through all the records in this table...\n                tableSchema[key] = (typeof(value) === 'object')                              // ... IF <value> is an object...\n                                 ? Object.keys(value)                                        //    ... overwrite it with its own list of keys, then use the result as the value (V) in the KVP output...\n                                 : \"<value> (\" + typeof(value) + \")\";                        // ... OTHERWISE (<value is NOT an object>) set value (V) to whatever its current data type happens to be...\n                return tableSchema;                                                          // ... and pass it back.\n            });\n        }\n\n        // db.tables.Teams.joinTo(db.tables.TeamMembers, 'teamID', 'teamID', 'eq')\n        // db.tables.Teams.joinTo(db.tables.TeamMembers, 'teamID', 'teamID', 'eq')\n        this.joinTo = (targData, targCol, thisData, thisCol, comparison='eq') => {\n            \n        }\n\n        root.createInstance(this.name);\n\n        \n\n        Object.defineProperties(this, {gi:this.gi, write:this.gi, go:this.go, read:this.read, go:this.gogo, read:this.readAll, schema:this.schema});\n    }\n}\n\nexport {__DBTable}","import {__DBTable} from \"./c_DBTable.js\"\n\nclass __TableStorage extends Array {\n    constructor(props) {\n        super(props);\n        console.log('__TableStorage :', __TableStorage, \"props : \", props);\n        // this.props  = props;\n        this.parent = props.__parent;\n        this.list   = props.__tables;\n        this.pop();\n\n        (() => {\n            let tblsToCreate = [...this.list];\n            tblsToCreate.map(tbl => new __DBTable({__root:this.parent, __name:tbl}));\n            Object.assign(this, this.tblsToCreate);\n        })();\n\n        console.log('Table Storage Initialized!', this);\n\n        // this._setList = (tblNames=[]) => {\n        //     if(typeof(tblNames) === 'string') tblNames = tblNames.split(',');\n        //     else if(!Array.isArray(tblNames)) throw new TypeError('Invalid Input to tables._setList()! Expected either string or array, got ' + typeof(tblNames) + ' (' + tblNames + ')!');\n        //     tblNames.forEach(tblName=>{\n        //         if(this.list.indexOf(tblName) === -1) this.list.push(tblName);\n        //     });\n        // }\n        \n        // // parent.getItem('tables')\n        // // .then(tblList => {\n        // //     const t=tblList\n        // //     if (tblList == null || (typeof(tblList) != 'string' && !Array.isArray(tblList))) {\n        // //         return [];\n        // //     }\n        // //     this.create(tblList);\n        // //     return tblList;\n        // // })\n        \n\n        // this.drop = (tblToDrop) => {\n        //     parent.removeItem(tblToDrop).then(() => {\n        //         this.list.splice(this.list.indexOf(tblToDrop), 1);\n        //         parent.setItem('tables', this.list);\n        //         console.log('Dropped Table ' + tblToDrop);\n        //     }).catch(function(err) {\n        //         // This code runs if there were any errors\n        //         console.error(\"Unable to drop table \" + tblToDrop + \" (\" + err + \")\");\n        //     });\n        // }\n\n        // this.create = ()=>{}\n\n        // this.loadTable = (tblNames) => {\n        // console.log('tblNames :', tblNames);\n        //                                if(typeof(tblNames) === 'string') tblNames = tblNames.split(',');\n        //                                else if(!Array.isArray(tblNames)) \n        //                                     throw new TypeError('Invalid Input to tables.create()! Expected either string or array, got ' + typeof(tblNames) + ' (' + tblNames + ')!');\n        //                                return Promise.all( tblNames.map( tblName=> {\n        //                                         this[tblName] =  parent.createInstance({name:tblName});\n        //                                         this[tblName].name = tblName;\n        //                                         this._setList(tblName);\n        //                                         return  parent.getItem('tables')\n        //                                                 .then(tblList => { \n        //                                                     if(tblList.indexOf(tblName) === -1){ \n        //                                                         tblList.push(tblName); \n        //                                                         parent.setItem('tables', tblList);\n        //                                                     } \n        //                                                     return tblList; \n        //                                                 })\n        //                                     })\n        //                                )\n        //                            }\n        // Object.defineProperties(this, {list:this.list, loadTable:this.loadTable, drop:this.drop});\n    }\n} \n\nexport {__TableStorage}"],"names":["__DBTable","Array","constructor","props","console","log","Object","assign","__name","parent","__parent","root","__root","isIterable","object","Symbol","iterator","bindTableInstance","__TableStorage","list","__tables","pop","tblsToCreate","map","tbl"],"mappings":";;;;;;IAAA,MAAMA,SAAN,SAAwBC,KAAxB,CAA8B;IAC1BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;IACf,UAAMA,KAAN;IACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BL,SAA3B,EAAsC,iBAAtC,EAAyDG,KAAzD,EAAgE,IAAhE;IAEAG,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBJ,KAApB;IAEA,SAAKK,MAAL,GAAcL,KAAK,CAACK,MAApB;IACA,SAAKC,MAAL,GAAcN,KAAK,CAACO,QAApB;IACA,SAAKC,IAAL,GAAYR,KAAK,CAACS,MAAlB;;IACA,SAAKC,UAAL,GAAkBC,MAAM,IAAKA,MAAM,IAAI,IAAV,IAAkB,OAAOA,MAAM,CAACC,MAAM,CAACC,QAAR,CAAb,KAAmC,UAAlF,CATe;;;IAYf,SAAKL,IAAL,CAAUM,iBAAV,CAA4B,KAAKT,MAAjC,EAAyC,IAAzC,EAZe;;IAgBf,WAhBe;IA0FlB;;IA3FyB;;ICE9B,MAAMU,cAAN,SAA6BjB,KAA7B,CAAmC;IAC/BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;IACf,UAAMA,KAAN;IACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCa,cAAhC,EAAgD,UAAhD,EAA4Df,KAA5D,EAFe;;IAIf,SAAKM,MAAL,GAAcN,KAAK,CAACO,QAApB;IACA,SAAKS,IAAL,GAAchB,KAAK,CAACiB,QAApB;IACA,SAAKC,GAAL;;IAEA,KAAC,MAAM;IACH,UAAIC,YAAY,GAAG,CAAC,GAAG,KAAKH,IAAT,CAAnB;IACAG,MAAAA,YAAY,CAACC,GAAb,CAAiBC,GAAG,IAAI,IAAIxB,SAAJ,CAAc;IAACY,QAAAA,MAAM,EAAC,KAAKH,MAAb;IAAqBD,QAAAA,MAAM,EAACgB;IAA5B,OAAd,CAAxB;IACAlB,MAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoB,KAAKe,YAAzB;IACH,KAJD;;IAMAlB,IAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ,EAA0C,IAA1C,EAde;IAiBf;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACH;;IAtE8B;;;;;;;;;;"}