{"version":3,"file":"flambe.js","sources":["_js/flambe.js"],"sourcesContent":["\n//@@ =====================================================================================================================================\n//@@ ========================================================= .CSV PARSER ===============================================================\n//@@ =====================================================================================================================================\nfunction round_to_precision(x, precision) {\n    _I(\"ES5 FUNCTION: round_to_precision\", \"x\", x, \"precision\", precision);\n    var y = +x + (precision === undefined ? 0.5 : precision / 2);\n    return y - (y % (precision === undefined ? 1 : +precision));\n}\n\nconst readableRound = (val, precision = 0, trimTrailing0s=1) => {\n    if (val == null || isNaN(val) || val == Infinity) return false; else val = parseFloat(val);\n    if (!isNaN(precision) && precision > 0 && trimTrailing0s === 1) trimTrailing0s = val.toString().indexOf('.') !== -1;\n    let moddedPrecision = (isNaN(precision) || precision < 0) ? 1 : precision,\n        fltPtAdjustment = (1 + new Array(moddedPrecision).fill(0).join('')) * 1;\n\n    val = Math.round(val * fltPtAdjustment) / fltPtAdjustment;\n    let valS = (trimTrailing0s) ? val : val.toPrecision(val.toString().split('.')[0].length + precision);\n    return trimTrailing0s ? val : valS;\n};\n\n/*eslint-disable*/\nvar CSV = {};\n(function (window, undefined) {\n    'use strict';\n\n\n\n\n\n    // Define local CSV object.\n\n    /**\n     * Split CSV text into an array of lines.\n     */\n    function splitLines(text, lineEnding) {\n        _I(\"ES5 FUNCTION: splitLines\", \"text\", text, \"lineEnding\", lineEnding);\n        var strLineEnding = lineEnding.toString(),\n            bareRegExp = strLineEnding.substring(1, strLineEnding.lastIndexOf('/')),\n            modifiers = strLineEnding.substring(strLineEnding.lastIndexOf('/') + 1);\n\n        if (modifiers.indexOf('g') === -1) {\n            lineEnding = new RegExp(bareRegExp, modifiers + 'g');\n        }\n\n        // TODO: fix line splits inside quotes\n        return text.split(lineEnding);\n    }\n\n    /**\n     * If the line is empty (including all-whitespace lines), returns true. Otherwise, returns false.\n     */\n    function isEmptyLine(line) {\n        _I(\"ES5 FUNCTION: isEmptyLine\", \"line\", line);\n        return (line.replace(/^[\\s]*|[\\s]*$/g, '') === '');\n    }\n\n    /**\n     * Removes all empty lines from the given array of lines.\n     */\n    function removeEmptyLines(lines) {\n        _I(\"ES5 FUNCTION: removeEmptyLines\", \"lines\", lines);\n        var i;\n\n        for (i = 0; i < lines.length; i++) {\n            if (isEmptyLine(lines[i])) {\n                lines.splice(i--, 1);\n            }\n        }\n    }\n\n    /**\n     * Joins line tokens where the value of a token may include a character that matches the delimiter.\n     * For example: \"foo, bar\", baz\n     */\n    function defragmentLineTokens(lineTokens, delimiter) {\n        _I(\"ES5 FUNCTION: defragmentLineTokens\", \"lineTokens\", lineTokens, \"delimiter\", delimiter);\n        var i, j,\n            token, quote;\n\n        for (i = 0; i < lineTokens.length; i++) {\n            token = lineTokens[i].replace(/^[\\s]*|[\\s]*$/g, '');\n            quote = '';\n\n            if (token.charAt(0) === '\"' || token.charAt(0) === '\\'') {\n                quote = token.charAt(0);\n            }\n\n            if (quote !== '' && token.slice(-1) !== quote) {\n                j = i + 1;\n\n                if (j < lineTokens.length) {\n                    token = lineTokens[j].replace(/^[\\s]*|[\\s]*$/g, '');\n                }\n\n                while (j < lineTokens.length && token.slice(-1) !== quote) {\n                    lineTokens[i] += delimiter + (lineTokens.splice(j, 1))[0];\n                    token = lineTokens[j].replace(/[\\s]*$/g, '');\n                }\n\n                if (j < lineTokens.length) {\n                    lineTokens[i] += delimiter + (lineTokens.splice(j, 1))[0];\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes leading and trailing whitespace from each token.\n     */\n    function trimWhitespace(lineTokens) {\n        _I(\"ES5 FUNCTION: trimWhitespace\", \"lineTokens\", lineTokens);\n        var i;\n\n        for (i = 0; i < lineTokens.length; i++) {\n            lineTokens[i] = lineTokens[i].replace(/^[\\s]*|[\\s]*$/g, '');\n        }\n    }\n\n    /**\n     * Removes leading and trailing quotes from each token.\n     */\n    function trimQuotes(lineTokens) {\n        _I(\"ES5 FUNCTION: trimQuotes\", \"lineTokens\", lineTokens);\n        var i;\n\n        // TODO: allow for escaped quotes\n        for (i = 0; i < lineTokens.length; i++) {\n            if (lineTokens[i].charAt(0) === '\"') {\n                lineTokens[i] = lineTokens[i].replace(/^\"|\"$/g, '');\n            } else if (lineTokens[i].charAt(0) === '\\'') {\n                lineTokens[i] = lineTokens[i].replace(/^'|'$/g, '');\n            }\n        }\n    }\n\n    /**\n     * Converts a single line into a list of tokens, separated by the given delimiter.\n     */\n    function tokenizeLine(line, delimiter) {\n        _I(\"ES5 FUNCTION: tokenizeLine\", \"line\", line, \"delimiter\", delimiter);\n        var lineTokens = line.split(delimiter);\n\n        defragmentLineTokens(lineTokens, delimiter);\n        trimWhitespace(lineTokens);\n        trimQuotes(lineTokens);\n\n        return lineTokens;\n    }\n\n    /**\n     * Converts an array of lines into an array of tokenized lines.\n     */\n    function tokenizeLines(lines, delimiter) {\n        _I(\"ES5 FUNCTION: tokenizeLines\", \"lines\", lines, \"delimiter\", delimiter);\n        var i,\n            tokenizedLines = [];\n\n        for (i = 0; i < lines.length; i++) {\n            tokenizedLines[i] = tokenizeLine(lines[i], delimiter);\n        }\n\n        return tokenizedLines;\n    }\n\n    /**\n     * Converts an array of tokenized lines into an array of object literals, using the header's tokens for each object's keys.\n     */\n    function assembleObjects(tokenizedLines) {\n        _I(\"ES5 FUNCTION: assembleObjects\", \"tokenizedLines\", tokenizedLines);\n        var i, j,\n            tokenizedLine, obj, key,\n            objects = [],\n            keys = tokenizedLines[0];\n\n        for (i = 1; i < tokenizedLines.length; i++) {\n            tokenizedLine = tokenizedLines[i];\n\n            if (tokenizedLine.length > 0) {\n                if (tokenizedLine.length > keys.length) {\n                    // throw new SyntaxError('not enough header fields');\n                    console.warn(\"The file you have just loaded contains the wrong number of header fields. This is usually indicative of either a long-running story being deleted mid-iteration, or that Theresa, scrum-master for Victor's teams has some 'splainin' to doooo.\");\n                }\n\n                obj = {};\n\n                for (j = 0; j < keys.length; j++) {\n                    key = keys[j];\n\n                    if (j < tokenizedLine.length) {\n                        obj[key] = tokenizedLine[j];\n                    } else {\n                        obj[key] = '';\n                    }\n                }\n\n                objects.push(obj);\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * Parses CSV text and returns an array of objects, using the first CSV row's fields as keys for each object's values.\n     */\n    CSV.parse = function (text, lineEnding, delimiter, ignoreEmptyLines) {\n        _I(\"ES5 FUNCTION: CSV.parse\", \"text\", text, \"lineEnding\", lineEnding, \"delimiter\", delimiter, \"ignoreEmptyLines\", ignoreEmptyLines);\n        var config = {\n            lineEnding: /[\\r\\n]/,\n            delimiter: ',',\n            ignoreEmptyLines: true\n        },\n\n            lines, tokenizedLines, objects;\n\n        // Empty text is a syntax error!\n        if (text === '') {\n            throw new SyntaxError('empty input');\n        }\n\n        if (typeof lineEnding !== 'undefined') {\n            if (lineEnding instanceof RegExp) {\n                config.lineEnding = lineEnding;\n            } else {\n                config.lineEnding = new RegExp('[' + String(lineEnding) + ']', 'g');\n            }\n        }\n\n        if (typeof delimiter !== 'undefined') {\n            config.delimiter = String(delimiter);\n        }\n\n        if (typeof ignoreEmptyLines !== 'undefined') {\n            config.ignoreEmptyLines = !!ignoreEmptyLines;\n        }\n\n        // Step 1: Split text into lines based on line ending.\n        lines = splitLines(text, config.lineEnding);\n\n        // Step 2: Get rid of empty lines. (Optional)\n        if (config.ignoreEmptyLines) {\n            removeEmptyLines(lines);\n        }\n\n        // Single line is a syntax error!\n        if (lines.length < 2) {\n            throw new SyntaxError('missing header');\n        }\n\n        // Step 3: Tokenize lines using delimiter.\n        tokenizedLines = tokenizeLines(lines, config.delimiter);\n\n        // Step 4: Using first line's tokens as a list of object literal keys, assemble remainder of lines into an array of objects.\n        objects = assembleObjects(tokenizedLines);\n\n        return objects;\n    };\n\n    // Expose local CSV object somehow.\n    if (typeof module === 'object' && module && typeof module.exports === 'object') {\n        // If Node module pattern is supported, use it and do not create global.\n        module.exports = CSV;\n    } else if (typeof define === 'function' && define.amd) {\n        // Node module pattern not supported, but AMD module pattern is, so use it.\n        //eslint-disable-next-line\n        define([], function () {\n            return CSV;\n        });\n    } else {\n        // No AMD loader is being used; expose to window (create global).\n        window.CSV = CSV;\n    }\n}(typeof window !== 'undefined' ? window : {}));\n/*eslint-enable*/\n//@@ =====================================================================================================================================\n\n//!! =====================================================================================================================================\n//!! ======================================================== FLAMBE PROPER ==============================================================\n//!! =====================================================================================================================================\n// DECLARATIONS //==================================================================================================================\n// Shortcut aliases and Helper functions //-----------------------------------------------------------------------------------------\nconst DEBUG_MODE = true;    //--> NOT TO BE SET TO 'TRUE' IN PRODUCTION USE - CONTROLS CONSOLE LOGS AND EXCESSIVE MEMORY CONSUMPTION\nconst INFO_TRACE = false;    //--> NOT TO BE SET TO 'TRUE' IN PRODUCTION USE - CONTROLS CONSOLE LOGS AND EXCESSIVE MEMORY CONSUMPTION\n\nconst d = document                                       // â¥± Alias - document\n    , qs = (s) => d.querySelector(s)                        // â¥± Alias - querySelector\n    , qsa = (s) => [...d.querySelectorAll(s)]                // â¥± Alias - querySelectorAll\n    , _ = (...args) => (DEBUG_MODE) ? console.log.call(this, ...args) : false     // â¥± Alias - _\n    , _I = (...args) => (DEBUG_MODE && INFO_TRACE) ? console.info.call(this, ...args) : false     // â¥± Alias - _\n    , _T = (...args) => (DEBUG_MODE) ? console.table.call(this, ...args) : false     //eslint-disable-line\n\n    // Rote memory's storage \n    /*eslint-disable*/\n    , rote = window.localStorage                                                                \t       \t// Alias to the window's localStorage. Really these are all just helper functions that amuse me.\n    , memories = () => rote.length                                                      \t\t// Returns the count of how many memories are being held in rote storage\n    , recall = (k, def = null) => { k = rote.getItem(k); return k ? k : (def ? def : null); }            \t\t// Returns a memory value if present. If not, returns def if provided, null if not\n    , muse = (k, def = null) => { r = recall(k, def); return r === def ? r : JSON.parse(r); }\n\n    , retain = (k, v) => rote.setItem(k, v) ? v : v                                        \t\t// Creates a new memory for key k with value v, then returns v\n    , reflect = (k, def = null) => retain(k, recall(k, def))                                        \t\t// Runs a recall for a memory (value at key or null), then immediately retains it in memories\n    , forget = (k) => rote.removeItem(k)                                                  \t\t// Discrads the memories at key k\n    , fugue = () => rote.clear()                                                      \t\t// Purges all memories... as though they'd NEVER. BEEN. FORMED. AT. ALL!\n    /*eslint-enable*/\n\n    , toHours = (val = null) => {                                                                   \t\t// Converts the asinine JIRA output we're currently getting (seconds, across the board) to hours\n        if (val === '---') { return val; }                                                           \t\t//  ... (except in the case of the starting value being '---' whereupon...\n        if (val == null) { return '0*'; }                                        \t\t                    //  ... we convert the value to something that still signifies the special case, but can also...\n        if (isNaN(val)) { return '0**'; }                                        \t\t                    //  ... we convert the value to something that still signifies the special case, but can also...\n        return (val / 1 <= 0) ? 0 : parseFloat((val / 3600).toPrecision(3));                                       \t\t//  ... still be coerced back into a number type by the interpreter)\n    }\n    , setTargetSlot = (slotIndex) => (targetSlot = slotIndex) // eslint-disable-line\n\n    , findLastIndexOf = (arr = void (0), val = void (0), fromIndex = null) => { // eslint-disable-line no-unused-vars\n        for (var i = arr ? arr.length - 1 : 0; arr !== void (0) && val !== void (0) && i >= 0; i--)\n            if (((val.constructor + '').match(/RegExp/) && arr[i].match(val)) || (val + '' == arr[i])) return (i);\n        return -1;\n    };\n\nconst totalItrDayPicker = document.querySelector('.picker-panel-presenter')\n\n\n    , getDayCountFromPicker = () => (totalItrDayPicker.placeholder / 1);\n\n// Global Variables --------------------------------------------------------------------------------------------------------------\nlet fileBuffer = []                                                                            \t\t// Stores copies of the file input's data collection (req'd in case the user maskes multiple sets of selections)\n    , safeBuffer = []\n    , namedFiles = []                                                                            \t\t// Array containing just the names of the files contained within fileBuffer (used for sequencing the read order)\n    , COMBD_DATA = []                                                                            \t\t// COMBINED DATA from all the files ingested\n    , DEBUG_DATA = []                                                                                   // PLACEHOLDER DATA container for use in debugging\n    , ISSUE_KEYS = []                                                                            \t\t// LIST OF ALL THE ISSUES from all the files ingested\n    , INTERPOL8D = []                                                                            \t\t// ARRAY OF ALL THE DATES that needed to be interpolated\n    , RPTDATA = []                                                                            \t\t//\n    , TOTALITRDAYS = getDayCountFromPicker()\n    , DAYSLOADED = 0                                                                             \t\t// THE NUMBER OF ACTUAL DAYS we have data for (basically lumps Seed and Day One into a single day)\n    , FILESLOADED = 0                                                                             \t\t// THE NUMBER OF FILES entered into the system, regardless of the number of DAYS in the iteration\n    , input = document.getElementById('input')                                              \t\t// HTML file <INPUT> field/drop target for uploading XLSX files into the system\n\n    , dateField = qs(\"#report-start-date\")                                                      \t\t// HTML date <INPUT> field representing the start of the iteration\n    , sortableList = qs('.has-draggable-children')                                                 \t\t// The <UL> containing the drag-drop-sortable list of files provided by the user\n    , doneButton = qs('.done-sorting')                                                        \t\t    // \"Run report\" button\n    , iterationName = qs(\"#iteration-name\")\n    , previewPanel = qs('.output-table')\n    , dataToGraph = null\n    , idealDayCount = null\n    , targetSlot = null;\n\n// APPLICATION SOURCE ============================================================================ ðŸ…”ðŸ…§ðŸ…”ðŸ…’ðŸ…¤ðŸ…£ðŸ…˜ðŸ…žðŸ… ðŸ…¢ðŸ…”ðŸ… ðŸ…¤ðŸ…”ðŸ…ðŸ…’ðŸ…” indicated by encircled digits (âž€-âžˆ)\nconst init = () => {                                                                                      \t\t// â“¿ Initiate application, chaining steps 1-3 above to file input's onChange\n    _I(\"\\n\\n====== INIT ======\\n\");\n    iterationName.value = recall('iterationName', '') || \"Team Byrnedown - Iteration \";                  // Seed the value set for the iteration's name (or blank if none is stored)...\n    iterationName.onkeyup = () => { retain('iterationName', iterationName.value); };                    \t\t// ... and set up the field's onKeyUp handler to save any changes henceforth.\n    iterationName.onchangd = () => { retain('iterationName', iterationName.value); };                  \t\t// ... aaaand again, some more, for onChange.\n    dateField.value = recall('reportStartDate', '');                                         \t\t// Do the same for the Start Date value, seeding it (or blank) if set...\n    dateField.onkeyup = () => { retain('reportStartDate', dateField.value); };                \t    \t// ... and establishing the onKeyUp listener to store any updates.\n    dateField.onchange = () => { retain('reportStartDate', dateField.value); };                \t\t    // ... and establishing the onChange listener to store any updates.\n    fileBuffer = recall('fileBuffer', null);                                             \t\t// Try and retrieve the fileBuffer in one exisits in Rote memories...\n    fileBuffer = (fileBuffer == null) ? [] : JSON.parse(fileBuffer);                    \t\t// ... and, if one does, rehydrate it. Otherwise, establish it as a new array.\n\n    let startingLength = 10;\n\n    if (fileBuffer.length > 0) {                                                                     \t\t// If we DID manage to restore a previous buffer...\n        namedFiles = retain('namedFiles', fileBuffer.flatMap(f => (f && f.fileName)               \t\t//    ... and, should it prove that we have a valid file for each (filled) index... ********\n            ? f.fileName            \t    \t//    ... reconstuct the list of previously-provided file names...\n            : ''));                 \t\t    //    ... otherwise, flag the individual record as having errored out.\n        startingLength = fileBuffer.length - 1;                                                     \t\t//    .. Finally, while we're at it, let's grab the number of files we're starting with.\n    }\n\n    if (fileBuffer.length <= 1) {                                                                        \t\t// If we FAILED to restore a previous buffer (or the one we DID errored out)...\n        namedFiles = reflect('namedFiles', []);                                                    \t\t//    ... grab theb previous buffer from rote memories (defaulting to [] if not present)...\n        if (typeof (namedFiles) === 'string') namedFiles = retain('namedFiles', namedFiles.split(','));         //    ... break our namedFiles back out too.\n    }\n\n    totalItrDayPicker.placeholder = startingLength;\n    syncSpinner(startingLength);                                                                            //## âžœâžœâžœ ðŸ…’ \n\n    resizeBufferArraysAndRebuildSlots();                                                                    //@@ âžœâžœâžœ ï¸ŽðŸ…‘ \n    syncSpinner();                                                                                          //## âžœâžœâžœ ðŸ…’ \n\n    input.addEventListener('change', e => {                                                                 //$ onChange Event handler for the individual <LI>'s; Allows files ot be added\n        _I(\"EVENT: input.addEventListener('change') e\", e);\n        if (targetSlot != null && input.files.length === 1) {                                                 // (Since, in the case of a bulk upload attempt, we'd have no slot and more than 1 file)\n            return addOrReplaceSingleFileAndParse();                                                        //!! âžœâžœâžœ ðŸ… \n        }\n    });\n};\n\n// const insertFileNodeBetween = (e, trgObj = e.target) => {\n//     _I(\"FUNCTION: insertFileNodeBetween\", \"e\", e, \"trgObj\", trgObj);                                        //$$ â’¹ â¬…â¬…â¬…ï¸Ž \n// // _(e, trgObj);\n//     if (trgObj.tagName !== 'LI') {\n//         // e.preventDefault();\n//         return (e.cancelBubble = true);\n//     }\n//     let targetIndex = trgObj.dataset.slot;\n//     fileBuffer.splice(targetIndex, 0, '');\n//     namedFiles.splice(targetIndex, 0, '');\n//     syncSpinner(((totalItrDayPicker.placeholder / 1) + 1));                                                 //## âžœâžœâžœ ðŸ…’ \n//     resizeBufferArraysAndRebuildSlots();                                                                    //@@ âžœâžœâžœ ðŸ…‘ \n// };\n\nconst insertFileNodeBetween = (e, trg = e.target) => {\n    _I(\"FUNCTION: insertFileNodeBetween\", \"e\", e, \"trg\", trg);                                        //$$ â’¹ â¬…â¬…â¬…ï¸Ž \n    if (!trg.dataset || !trg.dataset.insertion) {\n        // e.preventDefault();\n        return (e.cancelBubble = true);\n    }\n    let targetIndex = +trg.dataset.insertion;\n    fileBuffer.splice(targetIndex, 0, '');\n    namedFiles.splice(targetIndex, 0, '');\n    syncSpinner(((totalItrDayPicker.placeholder / 1) + 1));                                                 //## âžœâžœâžœ ðŸ…’ \n    resizeBufferArraysAndRebuildSlots();                                                                    //@@ âžœâžœâžœ ðŸ…‘ \n};\n\nconst syncSelect = (e, val) => {\n    let trg = e.target;\n    val = (val != null) ? val : trg.value;\n    let txtBox = trg.previousElementSibling.previousElementSibling;\n    txtBox.value = val;\n    retain(trg.id, val);\n    trg.blur();\n\n};\n\nconst setSelect = (sel, val) => {\n    if (sel == null || val == null) return false;\n    sel = (typeof (sel) === 'string') ? qs(sel) : sel;\n    sel.value = val;\n    syncSelect({ target: sel }, val);\n};\n\nlet ALLTEAMS = [];\nlet ALLITRS = [];\nconst generateTeamsAndIterationLists = () => {\n    ALLTEAMS = [];\n    ALLITRS = [];\n    for (let files in fileBuffer) {\n        let file = fileBuffer[files];\n        if (file != null && file != '') {\n            let teamsInFile = JSON.stringify(file.fileData, ['Component/s']);                 // Rip out all the teams in each file...\n            teamsInFile = JSON.parse(teamsInFile).flatMap(d => d['Component/s']);           // ... then flatten the results into a 1-dimensional array.\n            let itrsInFile = JSON.stringify(file.fileData, ['Sprint']);                                    // ... then do the same for iterations.\n            itrsInFile = JSON.parse(itrsInFile).flatMap(d => d['Sprint']);\n            ALLTEAMS = [...teamsInFile, ...ALLTEAMS];                                                // Append the new data to the running variable\n            ALLITRS = [...itrsInFile, ...ALLITRS];\n        }\n    }\n\n\n    ALLTEAMS = [...new Set(ALLTEAMS)].sort();                                                               // Finally, reduce both to collections containing only unique elements\n    ALLITRS = [...new Set(ALLITRS)].sort();\n\n\n    let teamsDD = qs('#selTeam'),\n        itrsDD = qs('#selIteration');\n\n    teamsDD.innerHTML = '<option>Show All Teams</option><option>' + ALLTEAMS.join('</option><option>') + '</option>';\n    itrsDD.innerHTML = '<option>Show All Iterations</option><option>' + ALLITRS.join('</option><option>') + '</option>';\n    teamsDD.addEventListener('change', syncSelect);\n    itrsDD.addEventListener('change', syncSelect);\n\n};\nsetSelect('#selTeam', recall('selTeam'));\nsetSelect('#selIteration', recall('selIteration'));\n// eslint-disable-next-line\nconst removeFileAtIndex = (trgBtn, isFilled) => {                                                                 //%% â’º â¬…â¬…â¬…ï¸Ž  Remove the file from the slot whose trashcan was clicked (both in the buffer and the UI)\n    _I(\"FUNCTION: removeFileAtIndex\", \"trgBtn\", trgBtn, \"isFilled\", isFilled);\n    let ind = trgBtn.dataset.index;\n    if (findLastIndexOf(namedFiles, /.+/) === 0) {\n        namedFiles[0] = retain('namedFiles', '');\n        fileBuffer[0] = retain('fileBuffer', '');\n        return resizeBufferArraysAndRebuildSlots();                                                         //@@ âžœâžœâžœ ðŸ…‘ \n    }\n// _(ind, trgBtn);\n    if (isFilled) {\n        namedFiles.splice(ind, 1, \"\");\n        fileBuffer.splice(ind, 1, \"\");\n    } else {\n        namedFiles.splice(ind, 1);\n        fileBuffer.splice(ind, 1);\n        incDec(-1);\n    }\n    return resizeBufferArraysAndRebuildSlots();                                                             //@@ âžœâžœâžœ ðŸ…‘ \n};\n\n\nconst resizeBufferArraysAndRebuildSlots = (newLen = ((totalItrDayPicker.placeholder / 1) + 1)) => {               //@@ â’· â¬…â¬…â¬…ï¸Ž Destroys the current buffer and UI, rebuilding them to reflect new state\n    _I(\"FUNCTION: resizeBufferArraysAndRebuildSlots\", newLen);\n    if (typeof (namedFiles) == 'undefined' || isNaN(newLen) || newLen < 0) return false;\n    let oldLen = (namedFiles && namedFiles.length) ? namedFiles.length / 1 : 0,\n        opStr = '';\n\n    namedFiles.length = newLen;\n    fileBuffer.length = newLen;\n    if (oldLen < newLen) {\n        namedFiles.fill('', oldLen);\n        fileBuffer.fill('', oldLen);\n    }\n    retain('namedFiles', namedFiles);\n    retain('fileBuffer', JSON.stringify(fileBuffer));\n\n    let interpolated = findLastIndexOf(namedFiles, /.+/);\n\n    for (let i = namedFiles.length - 1; i >= 0; i--) {\n        if (namedFiles.indexOf(namedFiles[i]) < i) namedFiles[i] = '';\n        let pList = ' class=\"drag-drop\" draggable=\"true\" '\n            , dSlot = ` data-slot=\"${(i > 0) ? i : 'S'}\" `\n            , fName = ` <label for=\"input\" onMouseDown=\"setTargetSlot(${i})\">\n                              ${(namedFiles[i].length > 40) ? namedFiles[i].slice(0, 25) + ' <b>â€¦</b> ' + namedFiles[i].slice(-70) : namedFiles[i]}\n                              <button class=\"remove-buttons\" data-index=\"${i}\" onMouseUp=\"removeFileAtIndex(this, true)\" />                            \n                           </label>`                                                                        //%% âžœâžœâžœ ðŸ…” \n            , arrID = ` id=\"file-slot-${i}\" `;\n\n        if (namedFiles[i] == '') {\n            if (i < interpolated) {                                                                       //%% âžœâžœâžœ ðŸ…” \n                fName = ` <label for=\"input\" onMouseDown=\"setTargetSlot(${i})\">\n                                No file specified (click to add, or leave blank to interpolate data from neighbors)\n                                <button class=\"remove-buttons\" data-index=\"${i}\" onMouseUp=\"removeFileAtIndex(this, false)\" />  \n                              </label>`;\n                pList += ' data-value=\"interpolated\"';\n            } else {\n                fName = ` <label for=\"input\" onMouseDown=\"setTargetSlot(${i})\">No file specified (click to add!)\n                                <button class=\"remove-buttons\" data-index=\"${i}\" onMouseUp=\"incDec(-1); released();\" />\n\n                            </label>`;\n            }\n        } else {\n            pList += ' data-value=\"stored\"';\n\n        }\n\n        let determinedPos   =   dSlot.replace(/data-slot=\"(.*)\"/, '$1').trim(),\n            newSlotMarkup   =   (determinedPos === 'S')\n                            ?   `<a href=\"#\" class=\"rowInserter insertBelow\" data-insertion=\"1\"></a>`\n                            :   `<a href=\"#\" class=\"rowInserter insertAbove\" data-insertion=\"${determinedPos}\"></a>\n                                 <a href=\"#\" class=\"rowInserter insertBelow\" data-insertion=\"${(+determinedPos + 1)}\"></a>`\n                            ;   \n        newSlotMarkup = `<li ${arrID + dSlot + pList}>${newSlotMarkup}${fName}</li>`;\n        opStr = newSlotMarkup + opStr;\n    }\n    while (sortableList.childElementCount > 0) sortableList.childNodes[0].remove();\n    sortableList.insertAdjacentHTML('beforeEnd', opStr);\n    qsa('.rowInserter').forEach(li => li.addEventListener('click', insertFileNodeBetween));                         //$$ âžœâžœâžœ ðŸ…“ \n\n    generateTeamsAndIterationLists();\n};\nconst addOrReplaceSingleFileAndParse = (slotId = targetSlot, liObj = qs('#file-slot-' + slotId)) =>                     //!! â’¶ â¬…â¬…â¬…ï¸Ž Inserts (or updates) a file at the specified slot (in both the buffer and the UI)\n{\n    let fileObj = input.files[0],\n        fileName = fileObj.name;\n\n    if (namedFiles.indexOf(fileName) != -1) return (alert('This file is already in use!'));\n// _(\"WORKING WITH PROVIDED FILE \", fileName, namedFiles.indexOf(fileName));\n    const readUploadedFileAsText = (fileObj) => {\n        _I(\"FUNCTION: readUploadedFileAsText\", \"fileObj\", fileObj);\n// _(\"readUploadedFileAsText\");\n        let reader = new FileReader();\n\n        return new Promise((resolve) => {\n            reader.onload = () => {\n                _I(\"FUNCTION: onload\");\n// _('onload Event fired...');\n                resolve(reader.result);\n            };\n            reader.readAsText(fileObj);\n        });\n    };\n\n    readUploadedFileAsText(fileObj)\n        .then(result =>\n            new Promise(resolve => {\n// _('...resolved\\n\".then()\" #1');\n                var opJSON = CSV.parse(result);                                                         //    Parse the .CSV file input, ...\n// _(opJSON);\n                let newJSONData = { fileName: fileName, fileData: opJSON };\n                fileBuffer[slotId] = newJSONData;\n                namedFiles[slotId] = fileName;\n                resolve();\n            })\n        )\n        .then(() => {\n// _('...resolved\\n\".then()\" #2');\n            resizeBufferArraysAndRebuildSlots();                                                            //@@ âžœâžœâžœ ï¸ŽðŸ…‘ \n            doneButton.disabled = false;\n            doneButton.addEventListener('click', runReport);                                                 //** âžœâžœâžœ ï¸ŽðŸ…— \n            return;\n        });\n};\n\nconst runReport = (obj = doneButton) => {                                                                    //** â¬…â¬…â¬…ï¸Ž â’½    Execute the preview grid and graphing methods \n    //  offerToPerformDayOneOverrideAdjustment()\n    // safeBuffer = Object.assign([], );\n    let pvTable = qs('.preview-table');\n    if (pvTable) pvTable.remove();\n    FILESLOADED = fileBuffer.filter(fb => fb != '').length;                                                // Increment our \"number of files we've read\" counter...\n    DAYSLOADED = FILESLOADED - 1;\n    if (DAYSLOADED < 0) return false;\n    // ... and the number of days that equates out to.\n    const sumHours = (hourColl) =>\n        hourColl.flatMap(s => { let sth = 0, retVal = parseInt(s['Remaining Estimate']); retVal = isNaN(retVal) || retVal === 'NaN' ? 0 : retVal; sth += retVal; return sth; });\n\n    if (TOTALITRDAYS > 2 && DAYSLOADED === 1) {\n        let seedDataCount = fileBuffer[0].fileData.length,\n            seedDatatotal = sumHours(fileBuffer[0].fileData);\n        let day1DataCount = fileBuffer[1].fileData.length,\n            day1Datatotal = sumHours(fileBuffer[1].fileData);\n        if (day1DataCount > seedDataCount || day1Datatotal > seedDatatotal) { // \n            offerToPerformDayOneOverrideAdjustment();\n        }\n    }\n\n\n    if (obj.disabled == true) return false;\n    COMBD_DATA = [];\n    ISSUE_KEYS = [];\n    DEBUG_DATA = [];\n\n    getDistinctKeysFromFiles();                                                                             //^^ âžœâžœâžœ ðŸ…• \n};\nfunction checkFilterMatch(fullDaysRecords, teamFilt, itrFilt) {\n    function escapeRegExp(string) {\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n    }\n\n    teamFilt = (teamFilt == null || teamFilt == '' || teamFilt == '*' || teamFilt.indexOf('Show All') === 0) ? '.*': escapeRegExp(teamFilt);\n    itrFilt  = (itrFilt  == null || itrFilt  == '' || itrFilt  == '*' || itrFilt.indexOf('Show All')  === 0) ? '.*': escapeRegExp(itrFilt);\n\n    if (fullDaysRecords != null) {\n        teamFilt = new RegExp(teamFilt, 'gim');\n        itrFilt  = new RegExp(itrFilt, 'gim');\n\n        let filteredRecords = fullDaysRecords.filter(\n            rtc => {\n                return (\n                    (teamFilt && rtc['Component/s'] != null && rtc['Component/s'].match(teamFilt))\n                    &&\n                    (itrFilt && rtc['Sprint'] != null && rtc['Sprint'].match(itrFilt))\n                );\n            }\n        );\n        return filteredRecords;\n    }\n    return false;\n}\n\nconst getDistinctKeysFromFiles = () => {                                                                    //^^ â¬…â¬…â¬…ï¸Ž â’»    Iterate through our files, constructing a unique JSON structure from them \n    safeBuffer = Object.assign([], JSON.parse(recall('fileBuffer')));                                                             // Duplicate the file buffer (so we're not mucking up our original, \"pure\" copy. This one's \"safe\" to screw with\n\n    while (safeBuffer.lastIndexOf('') === (safeBuffer.length - 1)) safeBuffer.pop();                         // Discard any blank indicies And the END of the stack. Those are \"missing\" days.\n    while (safeBuffer.indexOf('') != -1) safeBuffer[safeBuffer.indexOf('')] = 'INTERPOLATED';               // (...since any blanks in the middle of the stack get flagged as needing to be interpolated)\n    for (let files in safeBuffer) {                                                                         // Iterate all the files we've collected into the buffer...\n        let file = safeBuffer[files];                                                                       //  ... Alias the file (for convenience).\n        if (file !== 'INTERPOLATED') {                                                                        //  ... Assuming it's not flagged for interpolation, \n            safeBuffer[files].fileData = checkFilterMatch(file.fileData, recall('selTeam'), recall('selIteration'));            // PERFORM TEAM AND ITR FILTRATION HERE\n            let keySet = JSON.stringify(file.fileData, ['Issue key']);                                       //    ... pull out a flattened string containing ONLY the 'Issue key' columns\n            keySet = keySet.match(/\\bBSWM[A-Z0-9]{0,4}-\\d{2,6}\\b/g);                                                                 //    ... and then search the pattern DIGTDEV-####(##) out (any 4-6-digit number)\n            if (keySet != null && keySet !== '' && Array.isArray(keySet) && keySet.length > 0) ISSUE_KEYS = [...new Set([...ISSUE_KEYS, ...keySet])];                                          //    ... combine keySet and ISSUE_KEYS, remove duplicates, and convert back to an array.\n        } else INTERPOL8D.push(files);                                                                      //  ... UNLESS it IS flagged for interpolation, in which case add it to that collection  \n    }\n\n    remapDataSoIssueIDIsPrimaryKey();                                                                       //&& âžœâžœâžœ ðŸ…–\n};\n\nconst remapDataSoIssueIDIsPrimaryKey = () => {                                                              //&& â’¼ â¬…ï¸Žâ¬…ï¸Žâ¬…ï¸Ž    Iterate finalized buffer, and concatinated generate output data\n    _I(\"FUNCTION: remapDataSoIssueIDIsPrimaryKey\");\n    let temp_store = [];                                                                                        // Create a temporary, empty collection...\n    ISSUE_KEYS.forEach(r => {                                                                               //    ... Iterate through our unique keys from all files (from getDistinctKeysFromFiles)...\n        temp_store.push(r['Issue key']);                                                                    //    ... stuff 'em into said temp array...\n        COMBD_DATA[r] = new Array(safeBuffer.length).fill('');                                              //    ... and create an index to house the data within our Combined Data collection\n        if (DEBUG_MODE) DEBUG_DATA[r] = new Array(safeBuffer.length).fill('');                               //    (... and if we're debugging, may as well make a slot a flattened string copy too)\n    });\n\n    let prevDay, prevData;\n\n    for (let files in safeBuffer) {\n        let file = safeBuffer[files];\n        if (file !== 'INTERPOLATED') {\n            file = file.fileData;\n            console.groupCollapsed('Ingested File')\n            console.log('file :', file);\n            console.groupEnd();\n            file.forEach(f => {\n            console.log('f :', f);\n                if (f && f['Issue key'] && f['Issue key'] != null && f['Issue key'] !== '') {\n                    console.log('f[\\'Issue key\\'] :', f['Issue key']);\n                    COMBD_DATA[f['Issue key']][files] = f;\n                    if (DEBUG_MODE) DEBUG_DATA[f['Issue key']][files] = JSON.stringify(f);\n                }\n            });\n            prevDay = files;\n            prevData = file;\n            prevData = Object.assign([], safeBuffer[files]);\n        }\n    }\n    Object.keys(COMBD_DATA).forEach(cbd => {\n        INTERPOL8D.forEach(itp => COMBD_DATA[cbd][itp] = '---');\n    });\n    window.addEventListener('click', destroyExtantDetailPreviewers);\n    processParentChildRelationships();                                                                      //â¦¾! âžœâžœâžœ ðŸ…˜\n};\n\nconst destroyExtantDetailPreviewers = (forced=false) => {\n    if(!window.pReviewing || forced) [...qsa('.extra-details')].forEach(pp => pp.remove())\n};\n\nconst pReviewing = (e, eventTarget = e.target, engaged = false) => {\n    if(engaged) {\n        window.pReviewing = true;\n        window.clearTimeout(window.pReviewTimer);\n    }\n    else window.pReviewTimer = window.setTimeout(()=>{window.pReviewing = false; destroyExtantDetailPreviewers(true)}, 500000 );\n}\n\nconst showRecordDetails = (e, eventTarget = e.target || false) => {\n    if(!eventTarget) return false;\n    _I(\"FUNCTION: showRecordDetails\", \"e\", e, \"eventTarget\", eventTarget);\n    let recordIdToDisplay = null;\n    \n    if(eventTarget.dataset && eventTarget.dataset.recid) recordIdToDisplay = eventTarget.dataset.recid;\n    else{\n        eventTarget = eventTarget.closest('.issue-link');\n        if(eventTarget && eventTarget.innerText) recordIdToDisplay = eventTarget.innerText;\n    }\n    if (recordIdToDisplay == null) return false;\n    console.log('recordIdToDisplay :', recordIdToDisplay);\n    e.preventDefault(true);\n    destroyExtantDetailPreviewers(true);\n\n    function normalizeHours(inp){\n        if(inp == null || isNaN(inp)) return inp;\n        return toHours(inp) + 'h';\n    }\n    \n    let gatheredDetails = quickIndex.getLatestDetails(recordIdToDisplay),\n        flatData = '<div class=\"extra-details\">' + (Object.entries(gatheredDetails).map(kvp=>{\n            if(kvp[1].trim() === '') return\n            return (kvp[1].trim() === '') ? '' : `<span>${kvp[0]}</span><span>${teamDialog.performSubstitution(normalizeHours(kvp[1]))}</span>`;\n\n        }).join('') + '</div>');\n    eventTarget.insertAdjacentHTML('beforeEnd', flatData);\n    qs('.extra-details').addEventListener('mouseover', (e)=>pReviewing(e, e.target, true));\n    qs('.extra-details').addEventListener('mouseout', (e)=>pReviewing(e, e.target));\n};\nlet quickIndex;\nconst processParentChildRelationships = () => {                                                             //â¦¾! â’¾ â¬…ï¸Žâ¬…ï¸Žâ¬…ï¸Ž Correllates the parent tasks to their corresponding sub-tasks \n    _I(\"FUNCTION: processParentChildRelationships\");\n    const createJIRALink = (IssueId, isParent = false) => {\n        // _I(\"FUNCTION: createJIRALink\", \"IssueId\", IssueId, \"isParent\", isParent);\n        let hrefUrl = `href=\"https://jirasw.t-mobile.com/browse/${IssueId}\"' `,\n            clsName = `class=\"issue-${isParent ? 'parent-' : ''}link iss-hvr-lnk\" `;\n        let wndoTrg = `target=\"_blank\" `,\n            issueID = IssueId.replace(/(\\d-)(\\d+)/gi, '$1<b>$2</b>');\n\n        return `<a ${hrefUrl + clsName + wndoTrg}>${issueID}</a><span class=\"record-reviewer\" data-recid=\"${IssueId}\" />`;\n    };\n\n    var toc = {};\n    quickIndex = Object.entries(COMBD_DATA).map(e => {\n        // _I(\"FUNCTION: quickIndex\");\n        let opIssueObj = {}\n            , issueKey = e[0]\n            , issueData = e[1]\n            , fltrdRows = issueData.filter(col => typeof (col) === 'object')\n            , validRow = fltrdRows[fltrdRows.length - 1]\n            , issueId = validRow['Issue id'];\n\n        toc[issueId] = issueKey;\n        opIssueObj = {\n            key: issueKey\n            , iid: toc[validRow['Issue id']]\n            , pid: toc[validRow['Parent id']] || ''\n            , sts: validRow.Status\n            , ass: validRow.Assignee\n            , sum: validRow.Summary\n            , vld: validRow\n        };\n        opIssueObj.pathLinks = (opIssueObj.pid === '')\n            ? createJIRALink(opIssueObj.iid)\n            : createJIRALink(opIssueObj.pid, true)\n            + ' / ' + createJIRALink(opIssueObj.iid);\n        return opIssueObj;\n    });\n    quickIndex.toc = toc;\n    quickIndex.pathedName = (key) => {\n        // _I(\"FUNCTION: pathedName\", \"key\", key);\n        let results = quickIndex.find(qI => qI.key === key);\n        return (results && results.pathLinks) ? results.pathLinks : key;\n    };\n    quickIndex.lastStatus = (key) => {\n        // _I(\"FUNCTION: lastStatus\", \"key\", key);\n        let results = quickIndex.find(qI => qI.key === key);\n        return (results && results.sts) ? results.sts : '';\n    };\n    quickIndex.getLatestDetails = (key) => {\n        // _I(\"FUNCTION: getLatestDetails\", \"key\", key);\n        let results = quickIndex.find(qI => qI.key === key);\n        return (results && results.vld) ? results.vld : false;\n    };\n\n    constructPreviewAndReportData();\n\n};\nconst toggleGridWidth = (e, trg=e.target) => {\n    let panel  = qs('#output-panels'),\n        button = qs('#GrowShrink');\n    button.classList.toggle('expand');\n    setTimeout(()=>panel.classList.toggle('skinny'), 550);\n}\nconst constructPreviewAndReportData = () => {                                                         // â“º iterate concatinated output data, look for concern-suggestive trends and build our markup\n    const ensureValidValue = (variable, value, altVal = value, tolerateEmptyStr = false) => {\n        _I(\"FUNCTION: ensureValidValue\", \"variable\", variable, \"value\", value, \"altVal\", altVal, \"tolerateEmptyStr\", tolerateEmptyStr);\n        return (\n            typeof (value) === undefined\n            || value == null\n            || (!tolerateEmptyStr && value === '')\n            || value === '---'\n        ) ? ((altVal !== value) ? altVal : variable)\n            : value;\n\n    };\n// _('constructPreviewAndReportData', COMBD_DATA);\n    let MRKUP = [],                                                                                    // Collection of markup that'll we'll used to render both the HTML preview and the ultimate XLSX file output\n        _I_ = '||--||';                                                                                // The string delimiter we're using to distinguish one chunk of data from another. Our \"Split-target\"\n    Object.entries(COMBD_DATA).forEach((dataRecord, ind) => {                                          // Iterate across each Issue (the \"rows\") that we've ingested data for, to extract the following data:\n\n        // _(dataRecord);\n        let issueName = dataRecord[0]                                                                 //   - The specific issue being examined (just the name; eg. 'DIGIT-12345'. Also serves as the array key)\n            , issueData = dataRecord[1]                                                                 //   - The specific issue being examined (all the data for all the days for the files provided)\n            , colCt = issueData.length                                                                  //   - How many \"columns\" we're looking at\n            , opSts = ''\n            , ROWOP = ''                                                                                 //   - The iteratively-constructed markup for the \"row\" corresponding to the issue being examined\n            , opHrs = 0\n            , flags = ''                                                                                 //   - The empty collection of flags, to be joined & processed later in the loop\n            , reCtr = 1                                                                                  //   - Counter for how many consecutive days the Remaining Estimate has languished, unchanged\n            , ctCtr = 1                                                                                  //   - Iteration-length counter for how many consecutive days the Remaining Estimate goes unchanged\n            , oldRE = ''                                                                                 //   - Previous (from the previous-iterated-over day in the row) Remaining Hours Estimate\n            , oldPI = ''                                                                                 //   - Previous (from the previous-iterated-over day in the row) Parent ID\n            , oldII = ''                                                                                 //   - Previous (from the previous-iterated-over day in the row) Issue ID\n            , newRE = ''                                                                                 //   - Current (from the currently-iterated-over day in the row) Remaining Hours Estimate\n            , newPI = ''                                                                                 //   - Current (from the currently-iterated-over day in the row) Parent ID\n            , newII = ''                                                                                 //   - Current (from the currently-iterated-over day in the row) Issue ID\n            , newST = '';                                                                                //   - Current Status (in this case, we don't care what the previous one was, but need it at the issue scope)\n\n            console.log('issueName, issueData :', issueName, issueData);\n        issueData.forEach((datRec, ix) => {                                                             // ...Iterate the issue's collected data (the \"columns\"), gathering...\n            newRE = (datRec === '---') ? '---' : (datRec['Remaining Estimate'] || '---?');\n            if (newRE === '---') {\n                ROWOP = ROWOP + _I_ + '---';                                                           // Tack the current day being iterated past's Est. hours remaining onto the end of the issue being iterated past\n            } else\n                ROWOP = ROWOP + _I_ + toHours(newRE) + 'h';                                               // Tack the current day being iterated past's Est. hours remaining onto the end of the issue being iterated past\n        });\n        ROWOP = quickIndex.lastStatus(issueName) + _I_ + quickIndex.pathedName(issueName) + ROWOP;                                                           // STATUS | JIRA ID | PARENT ID | ISSUE ID | DAY 1 | DAY 2 | ... | DAY n | flags |\n        for (var backfill = colCt; backfill <= namedFiles.length - 1; backfill++) {\n            ROWOP += _I_ + 'XxXxX';\n        }\n        MRKUP.push(ROWOP.split(_I_));                                                                  // Convert it to an iterable collection and push it onto the bottom of the output markup stack\n    });\n\n    let colHeaders = ['Current Status', 'Issue ID', 'Seed Day']                  // Define always-present column headers (| Current Status | JIRA ID | Parent ID | Issue ID | Seed Day |)\n        , dateArr = [];                                                                               // Array holding the labels for each column, each of which represent the file being examined\n    if (dateField.checkValidity()) {                                                                   // Since we can't date-stamp a column if the user didn't give us a date, see if they did. IF they did...\n        if (colHeaders[4] === 'Seed Day') colHeaders[4] += \"<br>\" + dateField.value;                     // Append the Seed Date to the seed column header (if currently unset)\n        let startDate = new Date(dateField.value).getTime();                                           // Get the epoch value of the StartDate\n        let dayCt = 1;                                                                                 // Increment the number of days we're venturing forth from the start date. This is used to ignore weekends\n        while (dateArr.length < namedFiles.length - 1 && dayCt < namedFiles.length * 2) {                                                    // Keep going until we have at least 10 days\n            let incrementedDate = new Date(startDate + (dayCt * 86400000));                            // Add 24 hours to the daying bering iterated across\n            if (incrementedDate.getDay() > 0 && incrementedDate.getDay() < 6)                          // If the now-incremented date falls on a M-F...\n                dateArr.push('Day ' + (dateArr.length + 1) + '<br />' +                                //    ... add both the day number... \n                    incrementedDate.toLocaleDateString());                                  //    ... and the date that works out to to the stack.\n            dayCt++;                                                                                   // Increment the day counter whether we added to stack or not (since we skip over weekends and holidays)\n        }\n    } else {\n        for (let i = 1; i <= namedFiles.length - 1; i++)\n            if (i > safeBuffer.length - 1)\n                dateArr.push('XXXDay ' + i);\n            else\n                dateArr.push('Day ' + i);\n    }\n\n    colHeaders = [...colHeaders, ...dateArr];\n    let tblMarkup = '<button id=\"GrowShrink\" class=\"contract\" onclick=\"toggleGridWidth(this)\"></button><h1>' + iterationName.value + '</h1>' +\n        '<table class=\"preview-table\" cellspacing=\"0\">'\n        , hdrMarkup = '<thead><tr><th>' + colHeaders.join('</th><th>').replace(/>XXXDay/g, ' class=\"dim\">Day') +\n            '</th>'\n        , rowMarkup = '</tr></thead><tbody>';\n    MRKUP.forEach(o => rowMarkup += '<tr><td>' +\n        o.join('</td><td>').replace(/\\.00h|\\.0h/g, 'h').replace(/>XxXxX/g, ' class=\"dim\">') +\n        '</td></tr>');\n    rowMarkup += '</tbody>';\n    tblMarkup += hdrMarkup + rowMarkup +\n        '</tbody>';\n\n    while (previewPanel.childElementCount > 0) { previewPanel.childNodes[0].remove(); }\n    let cbPanel = document.getElementById('filter-ckbox-panel');\n    if (cbPanel) cbPanel.remove();\n\n    tblMarkup = teamDialog.performSubstitution(tblMarkup);\n\n    previewPanel.insertAdjacentHTML('beforeEnd', tblMarkup.replace(/<td>(0\\*+?)h<\\/td>/g, '<td class=\"major-alert\">$1h</td>'));\n    // previewPanel.insertAdjacentHTML('beforeEnd', tblMarkup.replace(/<td>0\\*h<\\/td>/g, '<td class=\"major-alert\">0*h</td>'));\n\n    [...qsa('a.iss-hvr-lnk')].forEach(lnk => {\n        // lnk.addEventListener('contextmenu', showRecordDetails);\n        let previewEyecon = lnk.nextElementSibling;\n        previewEyecon.addEventListener('mouseover', (e)=>{pReviewing(e, e.target, true); showRecordDetails(e, e.target);});\n        previewEyecon.addEventListener('mouseout', (e)=>pReviewing(e, e.target));\n    });\n\n    createReportData();\n\n\n\n    postProcessData();\n\n\n    window.asbestos.init();\n\n\n    let interpString = '',\n        genLength = RPTDATA[0].length;\n    INTERPOL8D.forEach(itpCol => interpString += `td:nth-of-type(-n + ${itpCol + 3}):nth-last-of-type(-n + ${genLength - 2 - itpCol}),`);\n    // interpString += `td:nth-of-type(-n + ${INTERPOL8D[0] - -3}):nth-last-of-type(-n + ${genLength - 2 - INTERPOL8D[0]}),`;\n// _(interpString);\n    //let fx=[...qsa((interpString.slice(0,-1)))].forEach(itpCell=>itpCell.className+=' interpolated-value');\n    return true;\n};\n\nconst msgBox = (title, msgText, callback = () => { this.parentNode.parentNode.remove(); }, type = 'yesno', buttonText = 'ok') => {\n    let boxUI = `<div id=\"msgbox\"><div id=\"msgbox-window\"><h3>${title}</h3><span>${msgText}</span>`;\n    if (type === 'yesno') boxUI += `\n                                    <button onclick=\"this.parentNode.parentNode.remove()\">No</button>\n                                    <button id=\"msgbox-prime\">Yes</button>\n                                `;\n    else boxUI += `<button id=\"msgbox-prime\">${buttonText}</button>`;\n    boxUI += `</div></div>`;\n    document.body.insertAdjacentHTML('afterBegin', boxUI);\n    qs(\"#msgbox-prime\").addEventListener('click', () => { qs(\"#msgbox\").remove(); callback(); qs(\"#msgbox\").remove(); });\n    return;\n};\n\nlet offerPerformed = false, genModSeeds = recall('genModSeeds');\nconst closeWindow = () => qs('#adjustement-panel').remove();\nconst reviseSeed = (newData) => {\n    function locateCorrespondingRecord(needle, haystack, propertyToCheck){\n        let straw = haystack.find(straws => (straws[propertyToCheck] === needle));\n        return straw || null;\n    }\n    let issueBoxes = qsa(\".adjustment-issue-check:checked\"),\n        seededSet  = fileBuffer[0][\"fileData\"],\n        dayOneSet  = fileBuffer[1][\"fileData\"];\n\n    issueBoxes = issueBoxes.map(iB => iB.id.replace('adjust-', ''));\n\n    issueBoxes.forEach(issueKey => {\n        let seededVersionOfIssue = locateCorrespondingRecord(issueKey, seededSet, \"Issue key\"),\n            dayOneVersionOfIssue = locateCorrespondingRecord(issueKey, dayOneSet, \"Issue key\");\n        if(seededVersionOfIssue === null)   seededSet.push(dayOneVersionOfIssue);\n        else                                seededVersionOfIssue = dayOneVersionOfIssue;\n\n        _(issueKey, seededVersionOfIssue, dayOneVersionOfIssue);\n    })\n    fileBuffer[0][\"fileData\"] = seededSet;\n    retain('fileBuffer', JSON.stringify(fileBuffer));\n    document.location.href = document.location;\n    closeWindow();\n};\n\nconst syncAdjCheckboxes = (fromMaster = false) => {\n    let masterBox         = qs(\"#adjustment-all\"),\n        issueBoxes        = qsa(\".adjustment-issue-check\");\n    masterBox.className   = \"adjustment-master\";\n    if (fromMaster) {\n        issueBoxes.forEach(b => { b.checked = masterBox.checked; });\n    } else {\n        let checkCount = 0;\n        issueBoxes.forEach(b => checkCount += b.checked ? 1 : -1);\n        if (Math.abs(checkCount) === issueBoxes.length) {\n            masterBox.checked = checkCount > 0;\n            // masterBox.className = (masterBox.checked) ? \"adjustment-master on\" : \"adjustment-master off\"\n        } else {\n            masterBox.checked = false;\n            masterBox.className += \" partial\";\n        }\n    }\n\n    issueBoxes.forEach(iB=>{\n        let teamTotCell = qs('#teamTot' + iB.dataset.affectsTeam),\n            typeTotCell = qs('#typeTot' + iB.dataset.affectsType);\n        let sumTotlCell = qs('#overallTot');\n\n        if(teamTotCell) teamTotCell.innerText = 'Â±0 hours';\n        if(typeTotCell) typeTotCell.innerText = 'Â±0 hours';\n        if(sumTotlCell) sumTotlCell.innerText = 'Â±0 hours';\n    });\n    let checkedIssueBoxes = qsa(\".adjustment-issue-check:checked\");\n    checkedIssueBoxes.forEach(cIB=>{\n        let teamTotCell = qs('#teamTot' + cIB.dataset.affectsTeam),\n            typeTotCell = qs('#typeTot' + cIB.dataset.affectsType);\n        let sumTotlCell = qs('#overallTot');\n        if(teamTotCell) teamTotCell.innerText = '+' + ((teamTotCell.innerText.replace(/[^\\d.]/g, '') * 1) + (cIB.dataset.issueImpact * 1)) + ' hours';\n        if(typeTotCell) typeTotCell.innerText = '+' + ((typeTotCell.innerText.replace(/[^\\d.]/g, '') * 1) + (cIB.dataset.issueImpact * 1)) + ' hours';\n        if(sumTotlCell) sumTotlCell.innerText = '+' + ((sumTotlCell.innerText.replace(/[^\\d.]/g, '') * 1) + (cIB.dataset.issueImpact * 1)) + ' hours';\n    });\n};\n\n// let seededSet, dayOneSet, revisedSeed, summaryTxts, summaryTots, seededFlat, lastMinAdds, seedFltKeys, missingStories, lastMinHrs;\n    \n\n\nconst performDayOneOverrideAdjustment = () => {\n    function locateCorrespondingRecord(needle, haystack, returnIndex=true){\n        for(var idx=0; idx<haystack.length; idx++) if(needle===haystack[idx]) return returnIndex ? idx : haystack[idx];\n        return null\n    }\n\n    if (offerPerformed || genModSeeds) return false;\n    offerPerformed        = true;\n    let lastMinAdds       = '',\n        lastMinHrs        = '',\n        teamsNewRec       = [],\n        summaryTxts       = [],\n        \n        seededSet         = fileBuffer[0][\"fileData\"],\n        dayOneSet         = fileBuffer[1][\"fileData\"],\n        seededFlat        = seededSet.flatMap(s   => s[\"Issue key\"]),\n        dayOneFlat        = dayOneSet.flatMap(s   => s[\"Issue key\"]),\n        teamKeyStr        = 'Component/s',\n        seededFlatKeys    = '_' + seededFlat.join('_') + '_',\n        // dayOneFlatKeys = '|' + dayOneFlat.join('|') + '|';\n\n        revisedSeed       = Object.assign([], seededSet),\n        alterdHours       = [],\n\n        missues           = dayOneFlat.filter(d1i => !new RegExp(`_${d1i}_`, 'gim').test(seededFlatKeys));\n    missues               = missues.map(m => {let newM = dayOneSet[locateCorrespondingRecord(m, dayOneFlat)]; newM.modded = 'ADD'; newM.modValue = newM['Remaining Estimate']*1; return newM; });\n\n    let newSeed           = [...seededSet, ...missues];\n    // newSeedFlat   = seededSet.flatMap(s => s[\"Issue key\"]);\n\n    newSeed.forEach(nSI => {\n        let relatedDay1Value = dayOneSet[locateCorrespondingRecord(nSI['Issue key'], dayOneFlat)],\n            newSeedEstHrsVal = nSI['Remaining Estimate'];\n        newSeedEstHrsVal = (newSeedEstHrsVal == null || newSeedEstHrsVal == '' || isNaN((newSeedEstHrsVal*1))) ? 0 : (newSeedEstHrsVal*1);\n        if(relatedDay1Value && relatedDay1Value['Remaining Estimate']){\n            relatedDay1Value = relatedDay1Value['Remaining Estimate'] * 1;\n            if(relatedDay1Value > newSeedEstHrsVal){\n                // _(nSI, nSI['Remaining Estimate'], relatedDay1Value, '\\n\\n========================');\n                nSI.oldValue = newSeedEstHrsVal;\n                nSI.modded   = 'AMEND';\n                nSI.modValue = relatedDay1Value - newSeedEstHrsVal;\n                nSI.newValue = relatedDay1Value;\n                nSI['Remaining Estimate'] = relatedDay1Value;\n            }\n        }\n    });\n\n    let updates  = [\n                        ...missues.sort((a, b) => b[teamKeyStr] - a[teamKeyStr]), \n                        ...newSeed.filter(nSI=>typeof(nSI.oldValue) !== 'undefined').sort((a, b) => b[teamKeyStr] - a[teamKeyStr])\n                    ];\n\n    let summaryOPUI = '';\n\n    summaryOPUI += `<div id='adjustement-panel'>\n                        <table cellpadding=\"0' cellspacing=\"0\">\n                            <thead>\n                                <tr><th colspan=\"5\">Optional Adjustments</th></tr>\n                                <tr>\n                                    <th>Team</th>\n                                    <th><input id=\"adjustment-all\" name=\"adjustment-all\" class=\"adjustment-master on\" type=\"checkbox\" value=\"*\" checked onclick=\"syncAdjCheckboxes(true)\" /></th>\n                                    <th>Issue ID</th>\n                                    <th>Change that would be made</th>\n                                    <th>Impact on Itr.</th>\n                                </tr>\n                            </thead>\n                            <tbody>`;\n    let freeText='', typeText='', typeIterating = '', teamIterating='', teamTotal=0, typeTotal=0, overallTotal=0, teamTotFld=0, typeTotFld=0;\n    updates.forEach(update=>{\n        typeText = (update.modded=='ADD') \n            ? `${update[\"Issue key\"]} would be added (adds ${toHours(update.modValue)} hours)` \n            : `${update[\"Issue key\"]} will increase in hours from ${toHours(update.oldValue)} to ${toHours(update.newValue)} (adds ${toHours(update.modValue)} hours)`;\n\n        if(typeIterating     !== update.modded){\n            if(typeIterating !== ''){\n                summaryOPUI += `<tr class=\"adjustment-type-subtotal-row\"><td colspan=\"4\">Sub-Total of Adjustments:</td><td id=\"typeTot${typeTotFld}\">+${typeTotal} hours</td></tr>`;\n                typeTotFld++;\n            }\n            typeTotal         = 0;\n            typeIterating     = update.modded;\n            summaryOPUI      += `<tr class=\"adjustment-type-row\"><td colspan=\"5\">${(typeIterating == 'ADD') ? \"Stories to be ADDED\" : \"Stories whose HOURS INCREASED\"}</td></tr>`;\n        }\n        if(update[teamKeyStr] !== teamIterating){\n            if(teamIterating  !== ''){\n                summaryOPUI += teamTotal !== 0 ? `<tr class=\"adjustment-team-subtotal-row\"><td colspan=\"4\">Team Impact:</td><td id=\"teamTot${teamTotFld}\">+${teamTotal} hours</td></tr>` : '';\n                teamTotFld++;\n            }\n            teamTotal         = 0;\n            teamIterating     = update[teamKeyStr];\n        } \n        summaryOPUI      += update.modValue !== 0 ? `<tr class = \"adjustment-team-name\"><td>${teamIterating}</td>` : '';\n\n        teamTotal    += (toHours(update.modValue) * 1);\n        typeTotal    += (toHours(update.modValue) * 1);\n        overallTotal += (toHours(update.modValue) * 1);\n        \n        summaryOPUI  += update.modValue !== 0 ? `<td><input id=\"adjust-${update[\"Issue key\"]}\" name=\"adjust-${update[\"Issue key\"]}\" class=\"adjustment-issue-check\" type=\"checkbox\" value=\"${update[\"Issue key\"]}\" checked data-issue-impact=\"${toHours(update.modValue)}\" data-affects-team=\"${teamTotFld}\" data-affects-type=\"${typeTotFld}\" onclick=\"syncAdjCheckboxes()\" /></td>\n                                                    <td>${update[\"Issue key\"]}</td>\n                                                    <td>${typeText}</td>\n                                                    <td><b>+${toHours(update.modValue)}</b> hrs.</td>\n                                                </tr>` : '';\n\n        freeText    += update.modValue === 0 ? `<tr class = \"adjustment-team-name\"><td>${update[teamKeyStr]}</td>\n                                                    <td><input id=\"adjust-${update[\"Issue key\"]}\" name=\"adjust-${update[\"Issue key\"]}\" class=\"adjustment-issue-check\" type=\"checkbox\" value=\"${update[\"Issue key\"]}\" checked data-issue-impact=\"0\" onclick=\"syncAdjCheckboxes()\" /></td>\n                                                    <td>${update[\"Issue key\"]}</td>\n                                                    <td>Freebie; If added, story won't impact the iteration/burndown.</td>\n                                                    <td>Â±0 hrs.</td>\n                                                </tr>` : '';\n        \n    });\n    summaryOPUI += teamTotal !== 0 ? `<tr class=\"adjustment-team-subtotal-row\"><td colspan=\"4\">Team Impact:</td><td id=\"teamTot${teamTotFld}\">+${teamTotal} hours</td></tr>` : '';\n    summaryOPUI += typeTotal !== 0 ? `<tr class=\"adjustment-type-subtotal-row\"><td colspan=\"4\">Sub-Total of Adjustments:</td><td id=\"typeTot${typeTotFld}\">+${typeTotal} hours</td></tr>` : '';\n    summaryOPUI += `<tr class=\"adjustment-type-row\"><td colspan=\"5\">FREEBIES</td></tr>`;\n    summaryOPUI += freeText;\n    summaryOPUI += `<tr class=\"adjustment-type-subtotal-row\"><td colspan=\"4\">Sub-Total of Adjustments:</td><td>Â±0 hours</td></tr>`;\n    summaryOPUI += `<tr class=\"adjustment-total-row\"><td colspan=\"4\">Cumulative Impact:</td><td id=\"overallTot\">+${overallTotal} hours</td></tr>`;\n    summaryOPUI += `\n                        <tr>\n                            <td colspan=\"5\">\n                                <input class=\"cta-adjustment secondary\" type=\"button\" onclick=\"closeWindow()\" value=\"Err... Never Mind\" />\n                                <input class=\"cta-adjustment primary\" type=\"button\" onclick=\"reviseSeed()\" value=\"Adjust Seed Values\" />\n                            </td>\n                        </tr>\n                        </tbody>\n                </table>\n            </div>`;\n\n    document.body.insertAdjacentHTML('afterBegin', summaryOPUI);\n\n\n\n\n    \n    // }\n};\nconst offerToPerformDayOneOverrideAdjustment = () => {\n    if (!offerPerformed && !genModSeeds) {\n        msgBox('Ruh-roh!', 'Looks like one or more of your scrumbags either failed to seed their hours before the start of the iteration, or \"remembered\" one or more stories just after the iteration started. <br /><br />Would you like me to correct that for you?', performDayOneOverrideAdjustment);\n    }\n    // performDayOneOverrideAdjustment();\n};\n\nconst createReportData = () => {\n    _I(\"FUNCTION: createReportData\");\n    let tableNode = document.querySelector('.preview-table'),\n        tHead = [...tableNode.querySelectorAll('th')].map(th => th.innerText),\n        tBody = [...tableNode.querySelectorAll('tr')].map(tr => [...tr.querySelectorAll('td')].flatMap(f => f.innerText));\n    tBody[0] = tHead;\n    RPTDATA = Object.assign([], tBody);\n};\n\nconst reFilterPreview = (obj) => {\n    _I(\"FUNCTION: reFilterPreview\", \"obj\", obj);\n    if (obj != null) {\n        let targetClass = obj.id.replace('chk-', '.row-status-');\n        [...document.querySelectorAll(targetClass)].forEach(row => {\n            row.className = obj.checked ? row.className.replace(' obfuscated', '') : row.className + ' obfuscated';\n        });\n    }\n    let totDisp = 0;\n    [...qsa('.status-filter-checkboxes')].forEach(cb => { totDisp += cb.checked ? (cb.value / 1) : 0; });\n    document.getElementById('record-ct').innerText = totDisp + ' records shown.';\n};\n\nlet rowNodes = [];\nlet colNodes = [];\nlet hdrRowNode = [];\nlet hdrColNodes = [];\nlet numericTotals = ['', ''];\nlet totalRow = [];\nlet idealRow;\nconst postProcessData = () => {\n    let rptStatuses = {}\n        , dispCkBoxes = ''\n        , uniqueStatuses = []\n        , RPTString = \"\"\n        , dataColCount = 0\n        , nonDataColCount = 2;\n\n    Promise.resolve().then(() => {\n        rowNodes = [...qsa('.preview-table tr')];\n        RPTString = JSON.stringify(RPTDATA);\n        rowNodes.forEach((rows, idx) => {\n            let row = [...rows.querySelectorAll('td')];\n            colNodes.push(row);\n            if (row && row[0] && row[0].innerText !== '') {\n                rowNodes[idx].className = 'preview-row preview-row-' + idx + ' row-status-' + row[0].innerText.replace(/\\s+/g, '_');\n                uniqueStatuses.push(row[0].innerText);\n            }\n            return rows;\n        });\n    }).then((res) => {\n        _I(\"THENABLE -> \", \"res\", res);\n        hdrRowNode = rowNodes.splice(0, 1)[0];\n        hdrColNodes = [...hdrRowNode.childNodes];\n// _('hdrRowNode', hdrRowNode);\n// _('rowNodes', rowNodes);\n// _('hdrColNodes', hdrColNodes);\n// _('colNodes', colNodes);\n\n\n        // Extarct the unique statuses and generate their respective checkboxes for the display filtes.\n        [...new Set(uniqueStatuses)].sort().forEach(status => {\n            let muStatus = status.replace(/\\s+/g, '_'),\n                statusRE = new RegExp(status, 'g');\n            rptStatuses[muStatus] = RPTString.match(statusRE).length;\n            dispCkBoxes += `<input name=\"chk-${muStatus}\" id=\"chk-${muStatus}\" class='status-filter-checkboxes' type=\"checkbox\" value=\"${rptStatuses[muStatus]}\" checked=\"true\" onChange=\"reFilterPreview(this)\" /><label for=\"chk-${muStatus}\">${status} (${rptStatuses[muStatus]})</label><br>`;\n        });\n        document.getElementById('output-panels').insertAdjacentHTML('beforeEnd', '<aside id=\"filter-ckbox-panel\" class=\"status-filters\"><h2>Currently Showing:</h2><span id=\"record-ct\"></span>' + dispCkBoxes + '<button class=\"asbestos-trigger\"></button></aside>');\n        reFilterPreview();\n    }).then((res) => {\n        _I(\"THENABLE -> \", \"res\", res);\n        // Interpolate any missing data into its respective columns, from left to right, top to bottom.\n        colNodes.forEach((reportRow, rowIndex) => {\n            reportRow.forEach((cols, colIndex) => {\n                let col = cols.innerText,\n                    cell = colNodes[rowIndex][colIndex];//qs(`.preview-table tr:nth-of-type(${rowIndex}) td:nth-of-type(${colIndex+1})`);\n                // _(cell == colNodes[rowIndex][colIndex]);\n                if (col === '---') {\n                    cell.className = 'interpolated-value';\n                    let p = cell.previousSiblingElement;\n                    var pCell = cell.previousSibling,\n                        pCellVal = pCell.innerText.replace(/h/g, '') / 1,\n                        nCell = cell.nextSibling,\n                        nCellVal = nCell.innerText;\n                    while (nCell && nCellVal === '' || nCellVal === '---') {\n                        if (nCell && nCell.innerText) {\n                            nCell = nCell.nextSibling;\n                            nCellVal = nCell.innerText;\n                        } else {\n                            nCell = void (0);\n                            nCellVal = '';\n                        }\n                    }\n                    nCellVal = nCellVal.replace(/h/g, '') / 1;\n                    var cellDiff = pCellVal - nCellVal,\n                        itpValue = nCellVal + cellDiff / 2,\n                        opString = (itpValue.toPrecision(3).replace(/0+$/g, '') + 'h').replace('.h', 'h');\n\n                    if (!isNaN(itpValue)) {\n                        opString = (opString === '0h') ? '<i>0h</i>' : '<strong><em>' + opString + '</em></strong>';\n                        cell.innerHTML = opString;\n                    }\n                }\n            });\n        });\n    }).then(() => { // Analysis\n        const num = val => val ? parseInt(val.replace(/\\D/gi, '')) : 0;\n        const formatFlags = (type, flagColl) => (!Array.isArray(flagColl) || flagColl.length === 0) ? '' : '<a href=\"#\" class=\"flag-icons ' + type + '-icon\"></a><dl><dt>' + flagColl.join('</dd><dt>').replace(/\\|/g, '</dt><dd>') + '</dd></dl>';\n\n        /**\n            noChangeInItr   = rowHrs.splice(2, rowHrs.length).reduce((acc, cur) => (acc === true || cur !== acc) ? true : acc) === true,\n            noChangeFor72   = rowHrs.slice(-3).every(v=>v===rowHrs[rowHrs.length-1]),\n            _(rowHrs,totHrsCols,seedHours,rowHoursFlat,last72HoursFlat, noChangeInItr,noChangeFor72);\n            if (!noChangeInItr && devHasBegun && /DEFINITION/i.test(seedStatus)) minor.push('Wrong Status|Work has begun on this story, therefore it must be out of definition phase!');\n            if (seedHours === 0 && !/COMPLETED|DEMO/i.test(seedStatus)) medium.push('Hours not set!|The iteration was begin without an hour estimate being set for this story!');\n            if (noChangeFor72) medium.push('Development Stalled!|There has been no change in the status/hours burned for this story in the last 3 days!');\n            if (noChangeInItr) medium.push('No movement!|There has been no change in the status/hours burned for this story for the full period of the iteration!');\n            if (newStoryMidItr) {\n            if (FILESLOADED > 2)\n            major.push('Story added mid-iteration!|This story which did not exist on the Seed Day has appeared in the iteration!');\n            }\n            if (delStoryFromItr) major.push('Story removed from iteration!|This story, which has been tracked from the Seed Day no longer appears in the iteration!')\n            _(major, medium, minor)\n            row[0].innerHTML += formatFlags('major', major);\n            if (major && major.length == 0) row[0].innerHTML += formatFlags('medium', medium);\n            if (major && major.length == 0 && medium && medium.length == 0) row[0].innerHTML += formatFlags('minor', minor);\n        */\n\n        rowNodes.forEach((rowObj, rowIdx) => {\n           \n            let minor           = [],\n                medium          = [],\n                major           = [],\n                critical        = [],\n                row             = rowObj.children,                                                                              // NodeList of the cells' DOM objects for the row being examined\n                rowHrs          = rowObj.innerText.replace(/[A-Z-]{8}\\d{5}/gi, '').replace(/(\\d+)h/gi, '$1 ').match(/\\d+/gi),  // Array of hours representing all columns in this row (ex        : [8, 8, 7, 6, 4, 2, 0, 0, 0, 0, 0])\n                totHrsCols      = rowHrs.length,                                                                                // Number of hours columns being examined (ex                    : 11, for a std length itr)\n                seedHours       = num(rowHrs[0]),                                                                               // Number of hours in seed column (ex                            : 8, for an 8h seed)\n                rowHoursFlat    = rowHrs.join('').replace(/ /g, ''),\n                last72HoursFlat = rowHrs.slice(-3).join('').replace(/ /g, ''),\n                allZeroes       = new Array(totHrsCols).fill(0).join(''),                                                       // String of zeroes whose length is number of hours cols (ex     : \"00000000000\" if a std length itr)\n                allSeedValue    = new Array(totHrsCols).fill(seedHours).join(''),                                               // String of seed values whose length is number of hours cols (ex: \"88888888888\" for an 8h seed)\n                finalDaysHours  = num(rowHrs[totHrsCols - 1]),\n                seedStoryNumber = row[1].innerText,\n                seedStatus      = row[0].innerText,\n                devHasBegun     = false,\n                newStoryMidItr  = false,\n                delStoryFromItr = false,\n                allItrZeroedOut = rowHoursFlat === allZeroes,\n                noChangeFor72   = rowHrs.slice(-3).join('') === new Array(3).fill(finalDaysHours).join(''),\n                noChangeInItr   = rowHoursFlat              === new Array(totHrsCols).fill(finalDaysHours).join('').replace(/ /g, ''),\n                zeroesAllItr    = parseInt(rowHrs.join('')) === 0,\n                runningValues   = seedHours;\n\n            for (var colIdx = row.length - 1; colIdx >= 2; colIdx--) {\n                let col = row[colIdx];\n\n                if (colIdx == row.length - 1 && col.innerText.indexOf('*') !== -1) delStoryFromItr = true;\n                if (!delStoryFromItr && col.innerText.indexOf('*') !== -1) newStoryMidItr = true;\n\n                if (!devHasBegun && seedHours !== num(col.innerText)) devHasBegun = true;\n            }\n\n\n            if (!noChangeInItr && devHasBegun && /DEFINITION/i.test(seedStatus)) minor.push('Wrong Status|Work has begun on this story, therefore it must be out of definition phase!');\n            if (seedHours === 0 && !/COMPLETED|DEMO/i.test(seedStatus)) medium.push('Hours not set!|The iteration was begin without an hour estimate being set for this story!');\n            else if (noChangeInItr && noChangeFor72 && !/COMPLETED|DEMO/i.test(seedStatus)) medium.push('No movement!|There has been no change in the status/hours burned for this story for the full period of the iteration!');\n            if (!noChangeInItr && noChangeFor72) medium.push('Development Stalled!|There has been no change in the status/hours burned for this story in the last 3 days!');\n            if (newStoryMidItr) {\n                if (FILESLOADED > 2)\n                    major.push('Story added mid-iteration!|This story which did not exist on the Seed Day has appeared in the iteration!');\n                // else\n\n            }\n            if (delStoryFromItr) major.push('Story removed from iteration!|This story, which has been tracked from the Seed Day no longer appears in the iteration!');\n\n            row[0].innerHTML += formatFlags('major', major);\n            if (major && major.length == 0) row[0].innerHTML += formatFlags('medium', medium);\n            if (major && major.length == 0 && medium && medium.length == 0) row[0].innerHTML += formatFlags('minor', minor);\n        });\n    }).then(() => { // Add Remove behavior on flags\n        var removeFlagIcon=(el, trg=el.target)=>{el.preventDefault(); trg.nextSibling.remove(); trg.remove();return false;}\n        qsa('.flag-icons').forEach(fi=>fi.addEventListener('click',removeFlagIcon))\n    }).then(() => { // Sum up our totals\n        totalRow = new Array(hdrColNodes.length-2).fill(0);\n        idealRow = new Array(hdrColNodes.length-2).fill(0);\n\n        for(var i=0; i<totalRow.length; i++){\n            let sum = 0;\n            [...qsa(\"#output-panels tr.preview-row td:nth-child(\" + (i+3) + \")\")].forEach((td,idx)=>{\n                let iText = td.innerText.replace(/[^\\d\\.]/g,'') / 1 || 0;\n                sum += iText;\n                if(i===0){ // Seed Column\n                    idealRow[0] = readableRound(sum,2,true);\n                    for(var ir=1; ir<idealRow.length; ir++) idealRow[ir] = readableRound(sum - ((sum / (TOTALITRDAYS)) * ir),2, true);\n                    totalRow[0] = `<td>${readableRound(sum, 2, true)}h</td>`;\n                }else{\n                    if(DAYSLOADED >= i)\n                        totalRow[i] = (sum > idealRow[i]) ? `<td class='over'>${readableRound(sum, 2, true)}h</td>` : `<td class='under'>${readableRound(sum, 2, true)}h</td>`;\n                    else\n                        totalRow[i] = '<td></td>';\n                }\n            });\n        }\n        let idealRowMarkup = `<tr class=\"ideal-row\"><td colspan=\"2\" class=\"total-label\">Total (Ideal):</td><td>${idealRow.join('h</td><td>')}h</td></tr>`,\n            totalRowMarkup = `<tr class=\"total-row\"><td colspan=\"2\" class=\"total-label\">Total (Actual):</td>${totalRow.join('')}</tr>`;\n        qs('.preview-table tbody').insertAdjacentHTML('beforeEnd', idealRowMarkup);\n        qs('.preview-table tbody').insertAdjacentHTML('beforeEnd', totalRowMarkup);\n\n        qsa('.ideal-row td:nth-child(n + ' + ( 3 + DAYSLOADED) + '), .total-row td:nth-child(n + ' + ( 3 + DAYSLOADED) + ')').forEach(dimIdeal => {dimIdeal.className = dimIdeal.className.replace(/extra-dim /, '') + 'extra-dim '});\n\n        dataToGraph = totalRow.join('|').replace(/[^\\d\\|\\.]/g, '').replace(/\\|0/g,'').split('|');\n// _(dataToGraph)\n        idealDayCount = idealRow.length; \n        return\n        \n    }).then((res) => {\n        renderCHARt(idealDayCount, dataToGraph);\n    });\n};\n//!! =====================================================================================================================================\n\n\n\n\n\n\nconst released = () => {\n    window.clearTimeout(ongoingtimer);\n    ongoing = false;\n};\n\nlet ongoing = false, ongoingtimer = null,\n    offset = (totalItrDayPicker.getBoundingClientRect().height - 2),\n    activeInteraction = false;\n\ntotalItrDayPicker.addEventListener('mouseOver', () => { activeInteraction = true; });\ntotalItrDayPicker.addEventListener('mouseOut', () => { activeInteraction = false; ongoing = false; });\ntotalItrDayPicker.addEventListener('blur', () => { activeInteraction = false; ongoing = false; });\nwindow.addEventListener('click', released);\n\nconst syncSpinner = (hardValue = null) => {                                                                   //## â’¸ â¬…â¬…â¬…ï¸Ž \n    _I(\"FUNCTION: syncSpinner\", \"hardValue\", hardValue);\n    if (hardValue != null && !isNaN(hardValue)) totalItrDayPicker.placeholder = hardValue;\n    TOTALITRDAYS = getDayCountFromPicker();\n    let control = totalItrDayPicker.parentElement;\n    offset = (totalItrDayPicker.getBoundingClientRect().height + 2);\n    control.style = \"--value:\" + (TOTALITRDAYS * offset * -1) + \"px\";\n    resizeBufferArraysAndRebuildSlots();                                                                    //@@ âžœâžœâžœ ï¸ŽðŸ…‘ \n};\n\n\nconst incDec = (dir, mechanical = true, dly = 750, scale = 1) => {\n    _I(\"FUNCTION: incDec\", \"dir\", dir, \"mechanical\", mechanical, \"dly\", dly, \"scale\", scale);\n\n    ongoing = true;\n    dly = (dly < 50) ? 50 : Math.log2(dly) * dly / 10.4;\n    let adjVal = dir * scale + parseInt(totalItrDayPicker.placeholder);\n    if (adjVal <= 1) adjVal = 1;\n    if (adjVal > 60) adjVal = 60;\n    totalItrDayPicker.placeholder = adjVal;\n    syncSpinner();                                                                                           //## âžœâžœâžœ ðŸ…’ \n    // mechanical = false;\n    // incDec(dir, false, dly, scale)\n    // if (ongoing && !mechanical) ongoingtimer = window.setTimeout(() => , dly);\n};\n\n\n\n//%% ====================================================================================================\n//%% ======================================== GRAPHING FUNCTIONS ========================================\n//%% ====================================================================================================\n\n\n//%% ====================================================================================================\n//%% ======================================== GRAPHING FUNCTIONS ========================================\n//%% ====================================================================================================\nfunction renderCHARt(totalDaysInIteration, remainingHoursPerDay) {\n// _('_renderCHARt', totalDaysInIteration, remainingHoursPerDay)\n    // 500, 450, 400, 350, 300, 250, 200, 150, 100, 50*, 0*\n    // totalDaysInIteration = 10;\n    // remainingHoursPerDay = [500,475,375,450,200,250];\n\n    let par = document.getElementById(\"burndownOutput\").parentNode;\n    let oHTML = document.getElementById(\"burndownOutput\").outerHTML;\n    document.getElementById(\"burndownOutput\").remove();\n    par.insertAdjacentHTML('beforeEnd', oHTML);\n\n    syncSpinner();\n    remainingHoursPerDay     = remainingHoursPerDay.slice(0, FILESLOADED);\n    console.info(totalItrDayPicker.placeholder);\n    totalDaysInIteration    -= 1;\n    \n    let iterationStartingHrs = remainingHoursPerDay[0],\n        totDaysInItrWithSeed = totalDaysInIteration + 1,\n\n        idealPlottedPtValues = [iterationStartingHrs],\n        interpolatedIndicies = [],\n        colorsForActualHours = [\"#009900\"],\n        pageSettings         = {};\n   \n    pageSettings.elements    = {\n        showPopover: {\n            checked : true\n        }\n    };\n\n\n\n\n    const c                  = document.getElementById(\"burndownOutput\"),\n        ctx                  = c.getContext(\"2d\"),\n        popoverObj           = document.getElementById(\"popover\"),\n        wholePi              = Math.PI * 2;\n\n    let largestActualHrValue = Math.max(...remainingHoursPerDay),\n        adjustedRowUnitValue = largestActualHrValue / 10,\n        gridScaleMultipliers = 50 / adjustedRowUnitValue,\n        gridSideMargins      = 50,\n        gridVertMargins      = 50,\n        canvasHeight         = 550,\n        canvasWidth          = 1050,\n        gridRowScale         = 50 / (Math.max(...remainingHoursPerDay) / 10),\n        gridColWidth         = Math.floor(canvasWidth / totDaysInItrWithSeed),\n        gridRowHeight        = 50;\n\n    const plot               = (day, val) => [plotX(day), plotY(val)],\n          plotX              = (day)      => readableRound(gridSideMargins + (gridColWidth * day) + (gridColWidth / 2)),\n          plotY              = (val)      => canvasHeight - (gridScaleMultipliers * val) + gridVertMargins\n        //   LightenDarkenColor = (col,amt) => (+('0x'+col.replace('#',''))+amt*0x010101).toString(16).padStart(6,0);  \n\n    // canvasWidth              = gridColWidth * (totalDaysInIteration - 1) - gridSideMargins;\n    \n\n\n    console.log(\"totalDaysInIteration\", totalDaysInIteration, \"\\nremainingHoursPerDay: \", remainingHoursPerDay, \"\\niterationStartingHrs: \", iterationStartingHrs, \"\\nidealPlottedPtValues: \", idealPlottedPtValues, \"\\ninterpolatedIndicies: \", interpolatedIndicies, \"\\ncolorsForActualHours: \", colorsForActualHours, \"\\npageSettings: \", pageSettings, \"\\nlargestActualHrValue\", largestActualHrValue, \"\\nadjustedRowUnitValue: \", adjustedRowUnitValue, \"\\ngridScaleMultipliers: \", gridScaleMultipliers, \"\\ngridSideMargins: \", gridSideMargins, \"\\ngridVertMargins: \", gridVertMargins, \"\\ncanvasHeight: \", canvasHeight, \"\\ncanvasWidth: \", canvasWidth, \"\\ngridRowScale: \", gridRowScale, \"\\ngridColWidth: \", gridColWidth, \"\\ngridRowHeight: \", gridRowHeight, \"\\nplot: \", plot, \"\\nplotX: \", plotX, \"\\nplotY: \", plotY, \"\\ncanvasWidth: \", canvasWidth);\n\n\n\n    // COLOR Helper Functions\n\n    const LightenDarkenColor = (colStr, amt, col = parseInt(colStr, 16)) => (((col & 0x0000FF) + amt) | ((((col >> 8) & 0x00FF) + amt) << 8) | (((col >> 16) + amt) << 16)).toString(16);\n\n    const posNegPrcntToGYRHex = (val, saturation = 1, intensity = 1) => {\n        let minMaxed = 2 * (Math.round(Math.min(Math.max(val, -50), 50))),\n            hVal = Math.round(60 * (minMaxed / 100) + 60);\n        let hex = RGBtoHEX(...HSVtoRGB(hVal, saturation, intensity));\n        return hex;\n    };\n\n    let HSVtoRGB = (h, s, v, f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0)) => [f(5), f(3), f(1)],\n        RGBtoHEX = (r, g, b) => \"#\" + [r, g, b].map(x => Math.round(x * 255).toString(16).padStart(2, 0)).join('');\n    let HSVtoHEX = (h = 0, s = 1, v = 1) => RGBtoHEX(...HSVtoRGB(h, s, v)),\n        rgbStrToHex = (rgbStr) => rgbStr && '#' + rgbStr.slice(4, -1).split(', ').map(x => (+x).toString(16).padStart(2, '0')).join('');\n\n\n    // Fill in any gaps in our data for the graph.\n    const interpolateMissingDays = (() => {\n        for (let i = 1; i < remainingHoursPerDay.length - 2; i++) {\n            if (remainingHoursPerDay[i] == -1) {\n                let bgnIndex = null,\n                    endIndex = null;\n                for (let b = i; b >= 0 && bgnIndex === null; b--) if (remainingHoursPerDay[b] != -1) bgnIndex = b;\n                for (let e = i; e >= 0 && endIndex === null; e++) if (remainingHoursPerDay[e] != -1) endIndex = e;\n                if (bgnIndex != null && endIndex != null) {\n                    let interpRange = endIndex - bgnIndex,\n                        perDiemVals = ((remainingHoursPerDay[endIndex] - remainingHoursPerDay[bgnIndex]) / interpRange);\n                    for (let v = bgnIndex + 1; v < endIndex; v++) {\n                        if (remainingHoursPerDay[v] == -1) remainingHoursPerDay[v] = readableRound((remainingHoursPerDay[v - 1] + perDiemVals), 2, true);\n                        interpolatedIndicies.push(v);\n                    }\n                }\n            }\n        }\n    })();\n    const seedIdealPoints = (() => {\n        let idealHoursPerDay = readableRound(iterationStartingHrs / (totDaysInItrWithSeed - 1), 2, true);\n\n        for (let i = 0; i < totDaysInItrWithSeed - 1; i++) {\n            idealPlottedPtValues.push(idealPlottedPtValues[i] - idealHoursPerDay);\n        }\n    })();\n\n    const clearGrid = () => {\n        ctx.clearRect(0, 0, c.width, c.height);\n    };\n\n    const drawBGGridPanel = () => {\n        clearGrid();\n        ctx.lineWidth = \"2\";\n        ctx.strokeStyle = \"#000\";\n        ctx.strokeRect(gridVertMargins, gridVertMargins, canvasWidth, canvasHeight);\n        ctx.fillStyle = '#eaeaea';\n        ctx.fillRect(gridVertMargins, gridVertMargins, canvasWidth-1, canvasHeight);\n    };\n\n    const drawColPanels = () => {\n        for (let i = 0; i <= totalDaysInIteration; i++) {\n            let disabled = i >= remainingHoursPerDay.length,\n                interped = interpolatedIndicies.indexOf(i) !== -1;\n\n            ctx.fillStyle = disabled ? '#eaeaea' : (interped) ? '#FAEFFF' : '#fff';\n            ctx.fillRect(gridSideMargins + (gridColWidth * i), gridVertMargins, gridColWidth, canvasHeight);\n\n            let lblVals = (i === 0) ? 'ITR' : i,\n                lblOSet = (i === 0) ? 21 : (i >= 10) ? 13 : 15;\n            let lblUnit = (i === 0) ? 'start' : 'day';\n\n            // if(disabled) ctx.globalAlpha = 0.4\n            ctx.fillStyle = '#333';\n            ctx.font = 'bold 25px monospace';\n            ctx.fillText(lblVals, plotX(i) - (lblVals.toString().length * 7), canvasHeight + 80);\n            ctx.fillStyle = '#666';\n            ctx.font = '16px monospace';\n            ctx.fillText(lblUnit, plotX(i) - lblOSet, canvasHeight + 95);\n        }\n    };\n    const drawGridLines = () => {\n        // seedHoverTriggers();\n        ctx.beginPath();\n        ctx.lineWidth = \"1\";\n        ctx.setLineDash([2, 2]);\n        ctx.strokeStyle = \"#DDD\";\n        for (let i = 0; i < totalDaysInIteration - 1; i++) {\n            ctx.moveTo(plotX(i) + (gridColWidth / 2), gridVertMargins);\n            ctx.lineTo(plotX(i) + (gridColWidth / 2), canvasHeight + gridVertMargins);\n        }\n        ctx.stroke();\n        ctx.beginPath();\n\n        for (let i = 1; i <= 10; i++) {\n            ctx.moveTo(gridSideMargins, i * gridRowHeight + gridVertMargins);\n            ctx.lineTo(canvasWidth + gridSideMargins, i * gridRowHeight + gridVertMargins);\n        }\n        ctx.stroke();\n    };\n\n    const generateYAxis = () => {\n        let yAxis = document.getElementById('yaxis');\n        yAxis.innerText = \"\";\n        for (var i = 0; i <= 11; i++) {\n            yAxis.innerText = i * readableRound(adjustedRowUnitValue) + ' ' + yAxis.innerText;\n        }\n    };\n\n\n    let plotIdealPoints = () => {\n        for (let i = 0; i <= idealPlottedPtValues.length; i++) {\n            ctx.beginPath();\n            ctx.lineWidth = \"2\";\n            ctx.setLineDash([]);\n            ctx.fillStyle = '#fff';\n            // ctx.strokeStyle = \"#08b2ed\";\n            ctx.strokeStyle = interpolatedIndicies.indexOf(i) !== -1 ? \"#AA66AA\" : \"#08b2ed\";\n\n            ctx.arc(plotX(i), plotY(idealPlottedPtValues[i]), 6, 0, wholePi);\n            ctx.fill();\n            ctx.stroke();\n        }\n    };\n\n    let drawIdealLine = () => {\n        ctx.beginPath();\n        ctx.strokeStyle = \"#08b2ed\";\n        ctx.moveTo(plotX(0), plotY(idealPlottedPtValues[0]));\n        ctx.lineTo(plotX(idealPlottedPtValues.length -1), plotY(0));\n        ctx.lineWidth = \"3\";\n        ctx.setLineDash([5, 4]);\n        ctx.stroke();\n    };\n\n    let preSeedPointColors = (dataObj = remainingHoursPerDay) => {\n        for (let i = 1; i <= dataObj.length; i++) {\n            let ideal = idealPlottedPtValues[i - 1],\n                actual = dataObj[i - 1],\n                hourDifference = ideal - actual;\n                //posNegPrcntToGYRHex(hourDifference);\n                let dotColor;\n                if(hourDifference >= 0){\n                    dotColor = \"#0C0\";\n                }else{\n                    dotColor = (actual / ideal >= 1.15) ? \"#E00\" : \"#EE2\"\n                }\n            colorsForActualHours.push(dotColor);\n        }\n    };\n\n    let drawBaseGrid = () => {\n        clearGrid();\n        drawBGGridPanel();\n        drawColPanels();\n        drawGridLines();\n        generateYAxis();\n        preSeedPointColors();\n    };\n\n    drawBaseGrid();\n    drawIdealLine();\n    plotIdealPoints();\n\n    let drawBarGraph = (dataObj = remainingHoursPerDay, showIdealBars = true) => {\n        var bar = c.getContext(\"2d\");\n        bar.globalAlpha = 0.7;\n        bar.beginPath();\n        let barShift = gridColWidth * -0.4,\n            barWidth = gridColWidth * 0.80;\n\n        for (let i = 0; i < idealPlottedPtValues.length; i++) {\n            if (i > DAYSLOADED) return false;\n            bar.fillStyle = \"#08b2ed\";\n            bar.lineWidth = \"2\";\n            bar.strokeStyle = \"#000\";\n            let ideal = idealPlottedPtValues[i];\n            if (i > dataObj.length - 1 || (dataObj[i] && dataObj[i] === ideal)) {\n                bar.fillRect(plotX(i) + barShift, plotY(ideal), barWidth, canvasHeight + gridVertMargins - plotY(ideal));\n            } else {\n                let actual = dataObj[i];\n\n                let hourDifference = ideal - actual;\n\n                // _(ideal, actual, hourDifference)\n                if (actual <= ideal) {\n                    bar.fillRect(plotX(i) + barShift, canvasHeight + gridVertMargins, barWidth, (-actual * gridRowScale));\n                    bar.fillStyle = colorsForActualHours[i + 1];\n                    bar.fillRect(plotX(i) + barShift, (canvasHeight + gridVertMargins) + (-actual * gridRowScale), barWidth, (gridRowScale * -hourDifference));\n                } else if (actual > ideal) {\n                    bar.fillRect(plotX(i) + barShift, canvasHeight + gridVertMargins, barWidth, -gridRowScale * ideal);\n                    bar.fillStyle = colorsForActualHours[i + 1];\n\n                    bar.fillRect(plotX(i) + barShift, (canvasHeight - (gridRowScale * ideal)) + gridVertMargins, barWidth, (gridRowScale * hourDifference));\n                }\n            }\n        }\n    };\n\n    let plotActualPoints = (dataObj = remainingHoursPerDay) => {\n        let plotPt = (startX, startY, radius = 10) => {\n            let point = new Path2D();\n            point.moveTo(startX, (startY + radius));\n            point.lineTo((startX + radius), startY);\n            point.lineTo(startX, (startY - radius));\n            point.lineTo((startX - radius), startY);\n            point.closePath();\n            return point;\n        };\n\n        let pts = c.getContext(\"2d\");\n        for (let i = 1; i <= dataObj.length; i++) {\n            if (i > DAYSLOADED + 1) return false;\n            let plottedPt = plotPt(plotX(i - 1), plotY(dataObj[i - 1])),\n                dotColor  = colorsForActualHours[i],\n                lineColor = dotColor;\n                \n                pts.globalAlpha = 1;\n                pts.strokeStyle = lineColor;\n                pts.setLineDash([]);\n                pts.lineWidth = \"2\";\n                pts.stroke(plottedPt);\n                pts.globalAlpha = 0.5;\n                pts.fillStyle = dotColor;\n                pts.fill(plottedPt, 'evenodd');\n                colorsForActualHours.push(dotColor);\n        }\n    };\n\n    let drawActualLabels = (dayIndex, drawText) => {\n\n        if (dayIndex > remainingHoursPerDay.length - 1 || dayIndex > DAYSLOADED) return '';\n        let actual = remainingHoursPerDay[dayIndex],\n            ideal = idealPlottedPtValues[dayIndex],\n            overUnder = ideal - actual;\n        if (overUnder === 0) return '';\n\n        let xOffset     = 0,\n            hours       = -readableRound(overUnder, 0, true),\n            percentage  = readableRound(100 - ((ideal / actual) * 100), 0),\n            plsMinHrs   = (hours > 0) ? '+' : '',\n            plsMinPerct = (hours > 0) ? '+' : '-';\n            hours       = plsMinHrs + hours + 'h';\n            percentage  = percentage + '%';\n\n        // if (overUnder < 0) {\n            let lblXLoc = plotX(dayIndex) + xOffset,\n                lblYLoc = plotY(remainingHoursPerDay[dayIndex]),\n                widthMx = gridColWidth * 0.95,\n                ln1Text = plsMinPerct,\n                ln2Text = percentage,\n                ln3Text = hours,\n                hrColor = colorsForActualHours[dayIndex+1],\n                yPosAdj = (overUnder <= 0) ? -42 : 37;\n                lblYLoc = yPosAdj + lblYLoc;\n\n        if(!drawText){\n            ctx.fillStyle = yPosAdj < 0 ? \"transparent\" : \"#FFF6\";\n            ctx.fillRect((lblXLoc - (widthMx / 2) - 5), (lblYLoc - 17), (widthMx + 10), 50);\n        }else{\n            ctx.textAlign = \"center\";\n            ctx.font = 'bold 36px monospace';       ctx.fillStyle = '#FFF';     ctx.fillText(ln1Text, lblXLoc - 1, lblYLoc -  1, widthMx); \n            ctx.font = 'bold 36px monospace';       ctx.fillStyle = '#000';     ctx.fillText(ln1Text, lblXLoc + 1, lblYLoc +  1, widthMx); \n            ctx.font = 'bold 36px monospace';       ctx.fillStyle = hrColor;    ctx.fillText(ln1Text, lblXLoc + 0, lblYLoc +  0, widthMx); \n            ctx.font = 'bold 20px monospace';       ctx.fillStyle = '#FFF';     ctx.fillText(ln2Text, lblXLoc - 1, lblYLoc + 16, widthMx); \n            ctx.font = 'bold 20px monospace';       ctx.fillStyle = '#000';     ctx.fillText(ln2Text, lblXLoc + 1, lblYLoc + 18, widthMx); \n            ctx.font = 'bold 20px monospace';       ctx.fillStyle = hrColor;    ctx.fillText(ln2Text, lblXLoc + 0, lblYLoc + 17, widthMx); \n            ctx.font = '12px monospace';            ctx.fillStyle = '#666';     ctx.fillText(ln3Text, lblXLoc + 0, lblYLoc + 29, widthMx);\n        }\n\n\n\n        //     // ctx.textAlign = \"left\";\n\n        //     // ctx.font = 'bold 16px monospace';\n        //     // ctx.fillStyle = ;\n        //     // ctx.fillText(\"BEHIND!\", plotX(dayIndex) + xOffset, plotY(remainingHoursPerDay[dayIndex]) - 15);\n\n        //     // ctx.font = '12px monospace';\n        //     // ctx.fillStyle = '#666';\n        //     // ctx.fillText(hours, plotX(dayIndex) + xOffset - 5, plotY(remainingHoursPerDay[dayIndex]) - 30);\n\n        //     // ctx.font = 'bold 22px monospace';\n        //     // ctx.fillStyle = '#000';\n        //     // ctx.fillText(percentage, plotX(dayIndex) + xOffset + 5, plotY(remainingHoursPerDay[dayIndex]) - 40);\n\n        // } else {\n        //     ctx.textAlign = \"center\";\n\n        //     ctx.font = '12px monospace';\n        //     ctx.fillStyle = colorsForActualHours[dayIndex + 1];\n        //     ctx.fillText(\"AHEAD!\", plotX(dayIndex) + xOffset, plotY(remainingHoursPerDay[dayIndex]) + 30);\n\n        //     ctx.font = '10px monospace';\n        //     ctx.fillStyle = '#666';\n        //     ctx.fillText(hours, plotX(dayIndex) + xOffset - 10, plotY(remainingHoursPerDay[dayIndex]) + 40);\n\n        //     ctx.font = '14px monospace';\n        //     ctx.fillStyle = '#000';\n        //     ctx.fillText(percentage, plotX(dayIndex) + xOffset - 7, plotY(remainingHoursPerDay[dayIndex]) + 55);\n\n        // }\n        //           \n    };\n\n\n    let drawLineGraph = (dataObj = remainingHoursPerDay) => {\n        let segs = c.getContext(\"2d\"),\n            prev = dataObj[0];\n\n        segs.strokeStyle = \"#000\";\n        segs.setLineDash([]);\n        segs.globalAlpha = 1;\n\n\n        for (let i = 0; i <= dataObj.length; i++) {\n            let ideal = idealPlottedPtValues[i - 1],\n                actual = dataObj[i - 1],\n                hourDifference = ideal - actual;\n            if (dataObj[i + 1]) {\n                segs.beginPath();\n                let segment = new Path2D(),\n                    sX = plotX(i),\n                    sY = plotY(dataObj[i]),\n                    eX = plotX(i + 1),\n                    eY = plotY(dataObj[i + 1]);\n                segment.moveTo(sX, sY);\n                segment.lineTo(eX, eY);\n\n                let gradient = ctx.createLinearGradient(sX, sY, eX, eY);\n                gradient.addColorStop(0, colorsForActualHours[i + 1]);\n                gradient.addColorStop(1, colorsForActualHours[i + 2]);\n                segs.strokeStyle = gradient;\n                segs.lineWidth = \"3\";\n                segs.filter = 'brightness(0.9)';\n                segs.stroke(segment);\n                segs.fill(segment);\n            }\n            drawActualLabels(i, false);\n        }\n\n        for (let i = 0; i <= dataObj.length; i++) {\n            drawActualLabels(i, true);\n        }\n    };\n\n    let shadeLineGraph = (dataObj = remainingHoursPerDay) => {\n        let segs = c.getContext(\"2d\"),\n            linePath = new Path2D(),\n            i;\n        segs.beginPath();\n        for (i = 0; i <= dataObj.length; i++) {\n            let sX = 100 + (i * 100),\n                sY = 650 - dataObj[i],\n                eX = 200 + (i * 100),\n                eY = 650 - dataObj[i + 1];\n            if (dataObj[i + 1]) {\n                linePath.moveTo(sX, sY);\n                linePath.lineTo(eX, eY);\n                //_('linePath.lineTo(',eX, eY,')');\n            } \n        }\n        linePath.lineTo(100 + ((dataObj.length - 1) * 100), 650 - idealPlottedPtValues[(dataObj.length - 1)]);\n        linePath.lineTo(100, 150);\n        linePath.closePath();\n\n        let gradient = ctx.createLinearGradient(100, 650 - idealPlottedPtValues[0], 200, 650 - idealPlottedPtValues[1]);\n        gradient.addColorStop(0, colorsForActualHours[i]);\n        gradient.addColorStop(1, colorsForActualHours[i + 1]);\n        segs.strokeStyle = '#000';\n        segs.lineWidth = \"3\";\n        segs.stroke(linePath);\n        segs.fillRule = \"evenodd\";\n        segs.fill(linePath);\n        // segs.stroke();\n\n    };\n\n    const labelGraphChart = () => {\n        ctx.textAlign = \"right\";\n            ctx.fillStyle = '#666';\n            ctx.font = '20px sans-serif';\n            let teamsDD = qs('#txtTeam').value;\n            let teamName = teamsDD || 'All Teams'\n            console.log('teamsDD, teamName :', teamsDD, teamName);\n            ctx.fillText(iterationName.value, 1090, 90);\n            ctx.font = '16px sans-serif';\n            ctx.fillText(teamName, 1080, 120);\n    }\n\n    drawBarGraph();\n    plotActualPoints();\n    drawLineGraph();\n    plotActualPoints();\n    labelGraphChart();\n    // shadeLineGraph()\n}\nsetTimeout(() => { window.scrollTo(0, 0); }, 500);\n\nwindow.addEventListener('DOMContentLoaded', init);"],"names":["CSV","window","undefined","splitLines","text","lineEnding","strLineEnding","toString","bareRegExp","substring","lastIndexOf","modifiers","indexOf","RegExp","split","isEmptyLine","line","replace","removeEmptyLines","lines","i","length","splice","defragmentLineTokens","lineTokens","delimiter","j","token","quote","charAt","slice","trimWhitespace","trimQuotes","tokenizeLine","tokenizeLines","tokenizedLines","assembleObjects","tokenizedLine","obj","key","objects","keys","console","warn","push","parse","ignoreEmptyLines","config","SyntaxError","String","module","define","amd","d","document","qs","s","querySelector","qsa","querySelectorAll","rote","localStorage","recall","k","def","getItem","retain","v","setItem","reflect","findLastIndexOf","arr","val","fromIndex","constructor","match","totalItrDayPicker","getDayCountFromPicker","placeholder","fileBuffer","namedFiles","TOTALITRDAYS","input","getElementById","dateField","sortableList","iterationName","init","value","onkeyup","onchangd","onchange","JSON","startingLength","flatMap","f","fileName","syncSpinner","resizeBufferArraysAndRebuildSlots","addEventListener","e","insertFileNodeBetween","trg","target","dataset","insertion","cancelBubble","targetIndex","syncSelect","txtBox","previousElementSibling","id","blur","setSelect","sel","ALLTEAMS","ALLITRS","generateTeamsAndIterationLists","files","file","teamsInFile","stringify","fileData","itrsInFile","Set","sort","teamsDD","itrsDD","innerHTML","join","newLen","isNaN","oldLen","opStr","fill","interpolated","pList","dSlot","fName","arrID","determinedPos","trim","newSlotMarkup","childElementCount","childNodes","remove","insertAdjacentHTML","forEach","li","released","clearTimeout","ongoingtimer","offset","getBoundingClientRect","height","hardValue","control","parentElement","style","setTimeout","scrollTo"],"mappings":"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"}